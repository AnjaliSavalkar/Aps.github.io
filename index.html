<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anjali Savalkar - Algorithmic Problem Solving Portfolio</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <link rel="stylesheet" href="style1.css" />
  </head>
  <body>
    <!-- NAVBAR -->
    <nav>
      <div class="left">
        <a href="/">Anjali Savalkar</a>
      </div>

      <div class="right">
        <a
          href="https://github.com/AnjaliSavalkar"
          target="_blank"
          rel="noopener noreferrer"
        >
          <i class="fa-brands fa-github"></i>
          <span>Github</span>
        </a>

        <a
          href="https://www.linkedin.com/in/anjali-savalkar-39998925a"
          target="_blank"
          rel="noopener noreferrer"
        >
          <i class="fa-brands fa-linkedin"></i>
          <span>LinkedIn</span>
        </a>

        <a href="mailto:savalkaranjali6@gmail.com">
          <i class="fa-solid fa-envelope"></i>
          <span>Email</span>
        </a>
      </div>
    </nav>

    <main>
      <!-- SECTION 1: Hero -->
      <section class="hero-section">
        <div class="content">
          <h1>
            Algorithmic Problem Solving<br />
            <span class="highlight">Portfolio</span>
          </h1>

          <div class="links">
            <a href="#academic-details"> <span>Academic Details</span> </a
            ><a href="#about_me-section">
              <span>About me</span>
            </a>
            <a href="#skills"> <span>Skills</span> </a
            ><a href="#projects">
              <span>Academic projects</span>
            </a>
            <a href="#domain">
              <span>Domain</span>
            </a>
            <a href="#business-case-study">
              <span>Business Use Cases</span>
            </a>
            <a href="#references-section">
              <span>References</span>
            </a>
          </div>
        </div>

        <div class="custom-shape-divider-bottom-hero">
          <svg viewBox="0 0 1200 120" preserveAspectRatio="none">
            <path
              d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V0Z"
              opacity="1"
              fill="#ffffff"
            ></path>
          </svg>
        </div>
      </section>

      <!-- SECTION 2: Academic Details -->
      <section id="academic-details" class="academic-details-section">
        <h2>Academic Details</h2>
        <dl>
          <dt>Name</dt>
          <dd>Anjali Savalkar</dd>

          <dt>SRN (Student Roll Number)</dt>
          <dd>01FE22BCS196</dd>

          <dt>Course Name</dt>
          <dd>Algorithmic Problem Solving</dd>

          <dt>Course Code</dt>
          <dd>24ECSE309</dd>

          <dt>Course Instructor</dt>
          <dd>Prakash Hegade</dd>

          <dt>University</dt>
          <dd>KLE Technological University</dd>

          <dt>Portfolio Topic/Domain</dt>
          <dd>
            <img
              src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg"
              alt="Amazon Logo"
              class="amazon-logo"
            />
          </dd>
        </dl>
      </section>

      <section id="about_me-section" class="objectives-section">
        <h2>About Me</h2>
        <div class="objectives-container">
          <div class="objective-item">
            <p>
              <strong>
                Hi, I'm Anjali Savalkar, a passionate web developer currently
                pursuing my Computer Science degree at KLE Technological
                University. My key interests lie in full-stack development,
                cloud computing, problem-solving, and applying Data Structures
                and Algorithms to optimize systems and build scalable, efficient
                solutions.
              </strong>
            </p>
            <p>
              <strong>
                This portfolio showcases my work on Amazon business use cases,
                where I’ve analyzed real-time challenges and proposed solutions
                using algorithms and system design principles. I’m actively
                looking for internship or entry-level opportunities where I can
                contribute meaningfully, collaborate with industry
                professionals, and grow as a developer, system thinker, and
                cloud enthusiast.
              </strong>
            </p>
            <p class="fun-fact">
              <strong>Fun Fact:</strong> I love debugging code almost as much as
              building it—it’s like solving a mystery with logic!
            </p>
          </div>
        </div>
      </section>

      <!-- SECTION 3: Skills -->
      <section id="skills" class="skills-section">
        <h2>Skills</h2>

        <div class="skills-container">
          <!-- Languages -->
          <div class="skill-category">
            <h3>Languages</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/1/18/C_Programming_Language.svg"
                  alt="C"
                />
                <p>C</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/1/18/ISO_C%2B%2B_Logo.svg"
                  alt="C++"
                />
                <p>C++</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/6/6a/JavaScript-logo.png"
                  alt="JavaScript"
                />
                <p>JavaScript</p>
              </div>
            </div>
          </div>
          <!-- Cloud & DevOps -->
          <div class="skill-category">
            <h3>Cloud & DevOps</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/9/93/Amazon_Web_Services_Logo.svg"
                  alt="AWS"
                />
                <p>AWS</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/4/4e/Docker_%28container_engine%29_logo.svg"
                  alt="Docker"
                />

                <p>Docker</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/3/39/Kubernetes_logo_without_workmark.svg"
                  alt="Kubernetes"
                />
                <p>Kubernetes</p>
              </div>
              <div class="skill-item">
                <img
                  src="images/ansible.jpeg"
                  alt="Ansible"
                  style="width: 40px; height: auto"
                />

                <p>Ansible</p>
              </div>
            </div>
          </div>

          <!-- Tools -->
          <div class="skill-category">
            <h3>Tools</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg"
                  alt="GitHub"
                />
                <p>GitHub</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/9/9a/Visual_Studio_Code_1.35_icon.svg"
                  alt="VS Code"
                />
                <p>VS Code</p>
              </div>
            </div>
          </div>

          <!-- Web Development -->
          <div class="skill-category">
            <h3>Web Development</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/6/61/HTML5_logo_and_wordmark.svg"
                  alt="HTML"
                />
                <p>HTML</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/d/d5/CSS3_logo_and_wordmark.svg"
                  alt="CSS"
                />
                <p>CSS</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg"
                  alt="React"
                />
                <p>React</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/d/d9/Node.js_logo.svg"
                  alt="Node.js"
                />
                <p>Node.js</p>
              </div>
            </div>
          </div>

          <!-- Databases -->
          <div class="skill-category">
            <h3>Databases</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img src="images/mongo.png" alt="MongoDB" />
                <p>MongoDB</p>
              </div>
              <div class="skill-item">
                <img src="images/mysql.png" alt="MySQL" />
                <p>MySQL</p>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="projects" class="projects-section">
        <h2>Academic Projects</h2>
        <div class="projects-container">
          <div class="project-card">
            <h3>Netflix Clone</h3>
            <p>
              A replica of the popular Netflix homepage, featuring a clean,
              modern interface with responsive design. This project demonstrates
              my ability to work with HTML, CSS, JavaScript, and React to create
              a user-friendly streaming platform experience.
            </p>
            <ul>
              <li>Front-End: React, CSS, JavaScript</li>
              <li>Features: Responsive Design, Carousel, Movie Grid</li>
            </ul>
            <p>
              The project includes a fully responsive homepage with a clean
              layout and smooth transitions between elements.
            </p>
          </div>

          <div class="project-card">
            <h3>Few-Shot Brain Tumor Segmentation</h3>
            <p>
              This project focuses on leveraging few-shot learning techniques
              for accurate segmentation of brain tumors. The goal was to use
              minimal labeled data while achieving high performance in detecting
              tumor regions in MRI scans.
            </p>
            <ul>
              <li>
                Approach: Few-Shot Learning, Transfer Learning, Semantic
                Segmentation
              </li>
              <li>Dataset: BraTS 2021</li>
              <li>Model: Custom CNN + Pre-trained Models (Unet)</li>

              <li>Tools: PyTorch, NumPy, OpenCV</li>
            </ul>
          </div>

          <div class="project-card">
            <h3>Shopper Commerce Website</h3>
            <p>
              A fully functional e-commerce website built with modern web
              technologies, offering a seamless shopping experience. Users can
              browse products, add to cart, and securely check out.
            </p>
            <ul>
              <li>Stack: HTML, CSS, JavaScript, React, Node.js, MongoDB</li>
              <li>
                Features: Product listing, cart system, order tracking, admin
                dashboard
              </li>
              <li>
                Authentication: User login, registration, and JWT-based session
                management
              </li>
            </ul>
          </div>
        </div>
      </section>

      <!-- SECTION 4: Domain -->
      <section id="domain" class="domain-section">
        <h2>Domain - Amazon</h2>

        <div class="domain-container">
          <div class="domain-details">
            <div class="statement">
              <p>
                Amazon is a global technology company recognized for its
                innovation and leadership in multiple domains including
                e-commerce, cloud computing (AWS), digital streaming, and
                artificial intelligence.
              </p>
              <p>
                Amazon's mission is to be "Earth's most customer-centric
                company," constantly striving to improve customer experience
                through technology and efficiency.
              </p>
            </div>

            <div class="services">
              <h3>Amazon Services:</h3>
              <div class="service-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/9/93/Amazon_Web_Services_Logo.svg"
                  alt="AWS Logo"
                />
                <div>
                  <h4>Amazon Web Services (AWS)</h4>
                  <p>
                    Amazon Web Services (AWS) is the world’s leading cloud
                    computing platform, offering scalable solutions for compute
                    power, storage, AI/ML, security, and more. It powers a
                    significant portion of the internet and holds approximately
                    31% of the global cloud market share.
                  </p>
                </div>
              </div>

              <div class="service-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/d/de/Amazon_icon.png"
                  alt="Amazon E-commerce Icon"
                />
                <div>
                  <h4>E-commerce Platform</h4>
                  <p>
                    Amazon is the world’s largest online marketplace, serving
                    hundreds of millions of users globally. It offers a vast
                    selection of products on Amazon.com, enhanced by
                    personalized recommendations, fast shipping, and customer
                    reviews.
                  </p>
                </div>
              </div>

              <div class="service-item">
                <img src="images/prime.png" alt="Prime Video Icon" />
                <div>
                  <h4>Prime Video & Digital Streaming</h4>
                  <p>
                    Amazon Prime offers fast shipping, video streaming, and
                    music, serving millions with movies, shows, and original
                    content.
                  </p>
                </div>
              </div>
              <div class="service-item">
                <img src="images/alexa.png" alt="Prime Video Icon" />
                <div>
                  <h4>Alexa</h4>
                  <p>
                    Amazon’s voice-powered assistant for smart home and IoT.
                  </p>
                </div>
              </div>

              <div class="service-item">
                <img src="images/logistic.png" alt="Prime Video Icon" />
                <div>
                  <h4>Amazon Logistics</h4>
                  <p>
                    Advanced delivery and fulfillment network, including drone
                    and robotic delivery innovations.
                  </p>
                </div>
              </div>
            </div>
            <div class="statement">
              <p>
                <strong>Amazon’s ecosystem</strong> is a complex digital
                infrastructure that thrives on optimization and intelligent
                automation. This portfolio demonstrates how theoretical
                knowledge of algorithms can be harnessed to improve key
                functionalities across Amazon’s services.
              </p>

              <p>
                Each case study includes a real-world challenge, a DSA-based
                solution, and a performance analysis to quantify the impact.
              </p>

              <p>
                <em
                  >Join me as we explore the intersection of theory and
                  application in one of the world’s most advanced digital
                  ecosystems — Amazon.</em
                >
              </p>
            </div>
          </div>
        </div>
      </section>

      <!-- <section id="objectives-section" class="objectives-section">
        <h2>Objectives</h2>
        <div class="objectives-container">
          <div class="objective-item">
            <p>
              <strong>To apply advanced algorithms and data structures</strong>
              to enhance the speed, scalability, and operational efficiency of
              Amazon's diverse services including e-commerce, logistics, cloud
              computing, and digital media.
            </p>
          </div>
          <div class="objective-item">
            <p>
              <strong
                >To demonstrate the practical application of concepts from Data
                Structures and Algorithms (DSA) and Algorithmic Problem Solving
                (APS)</strong
              >
              by addressing real-world engineering challenges in Amazon's
              large-scale systems.
            </p>
          </div>
          <div class="objective-item">
            <p>
              <strong
                >To propose algorithmic solutions that optimize customer
                experience, improve supply chain and fulfillment accuracy,
                enhance search and recommendation systems, and maximize business
                outcomes</strong
              >
              across Amazon's technological ecosystem.
            </p>
          </div>
        </div>
      </section> -->
      <!-- SECTION 4: Skills -->

      <!-- SECTION 5: Business Use Cases -->
      <section id="business-case-study" class="business-case-study-section">
        <h2>Business Use Cases</h2>

        <h3>1. Amazon Ecommerce Use Cases</h3>
        <figure style="text-align: center">
          <img
            src="system-design/amazon-ecom.jpg"
            width="100%"
            height="700px"
            style="border: none"
            alt="Amazon eCommerce System Design"
          />
          <figcaption style="margin-top: 8px; font-style: italic; color: #555">
            Figure 1: Amazon eCommerce System Design Architecture
          </figcaption>
        </figure>

        <h5>click on each use case to explore more!</h5>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.1 Amazon Product Search Optimization using B-Tree Indexing
          </div>
          <div class="use-case-content">
            <p>
              Amazon’s e-commerce platform handles a massive and dynamic product
              catalog. To deliver fast and accurate search results, efficient
              indexing structures are essential for managing real-time updates,
              ensuring low-latency queries, and enhancing customer experience.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Handling huge, constantly changing product catalog</li>
              <li>Real-time updates with minimal delay</li>
              <li>Low latency for instant search results</li>
            </ul>
            <!-- <img
              src="system-design/bt-tree.jpg"
              alt="B-Tree structure used in indexing"
              width="100%"
              height="600px"
              style="border: none"
            /> -->
            <figure style="text-align: center">
              <img
                src="system-design/bt-tree.jpg"
                alt="B-Tree structure used in indexing"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 2: Workflow of Amazon Product Search Using B-Tree
                Indexing
              </figcaption>
            </figure>

            <h5>Algorithm: B-Tree</h5>
            <p>
              B-Trees are balanced multi-way search trees designed to
              efficiently manage large blocks of data. They organize keys in a
              sorted manner and keep all leaf nodes at the same level, ensuring
              balanced structure for consistent operations.
            </p>
            <h5>Design Principles:</h5>
            <ul>
              <li>Balanced multi-way tree</li>
              <li>Sorted keys in nodes</li>
              <li>Supports dynamic updates</li>
            </ul>
            <!-- <img
              src="gif/btree.gif"
              width="100%"
              height="600px"
              style="border: none"
            /> -->
            <figure style="text-align: center">
              <img
                src="gif/btree.gif"
                alt="B-Tree structure animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 3: B-Tree Algorithm Visualization[12]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              <strong>Scenario:</strong> A seller lists a new product,
              <em>“iPhone 15 Pro”</em>, on Amazon at 3 PM. The system inserts
              this into the B-Tree index, preserving order and balance. When a
              customer searches for “iPhone,” the B-Tree enables a quick
              <strong>O(log n)</strong> lookup to retrieve results instantly.
            </p>
            <p>
              If the product is removed later, the B-Tree deletes the entry and
              rebalances, maintaining search efficiency. These operations ensure
              minimal latency and always up-to-date search results, enhancing
              the customer’s shopping experience and improving conversion rates.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li><strong>Search Time Complexity:</strong> O(log n)</li>
              <li><strong>Insertion Time Complexity:</strong> O(log n)</li>
              <li><strong>Deletion Time Complexity:</strong> O(log n)</li>
              <li><strong>Space Complexity:</strong> O(n)</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Faster search results improve user satisfaction</li>
              <li>Lower infrastructure costs through efficient indexing</li>
              <li>Higher conversion rates by quick product discovery</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/b_tree.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View B-Tree Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.2 Enhancing Product Search with Autocomplete
          </div>
          <div class="use-case-content">
            <p>
              On platforms like Amazon, the autocomplete feature enhances the
              search experience by providing relevant suggestions as users begin
              typing. This improves usability, reduces typing effort, and helps
              customers discover products faster.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Delivering fast prefix-based suggestions</li>
              <li>Handling large and dynamic search dictionaries</li>
              <li>Ensuring real-time performance with low latency</li>
            </ul>
            <!-- <img
              src="system-design/trie.jpg"
              width="100%"
              height="600px"
              style="border: none"
            /> -->
            <figure style="text-align: center">
              <img
                src="system-design/trie.jpg"
                alt="Trie structure"
                style="
                  width: 40%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 4: Workflow of Amazon's Autocomplete System Using
                Trie-Based Prefix Indexing
              </figcaption>
            </figure>

            <h5>Algorithm:Trie (Prefix Tree)</h5>

            <p>
              Trie is a tree-based structure that enables fast lookups by
              storing words character by character. It allows for efficient
              prefix matching, making it ideal for real-time search suggestions.
            </p>
            <h5>Design Principles:</h5>
            <ul>
              <li>Divide and Conquer</li>
              <li>Prefix Sharing</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/trie.gif"
                alt="A* Algorithm Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 5: Visualization of Trie Algorithm [11]
              </figcaption>
            </figure>

            <h5>Real-Time Usage</h5>
            <p>
              When a user types <strong>"head"</strong>, the system traverses
              through the Trie: <code>h → e → a → d</code> and instantly fetches
              suggestions like <em>"headphones"</em>, <em>"headset"</em>, and
              <em>"headlamp"</em>. This ensures fast user interaction and
              efficient product discovery.
            </p>

            <h5>Algorithm Performance Analysis:</h5>

            <p>Time Complexity:</p>
            <ul>
              <li><strong>Insertion:</strong> O(k), where k is word length</li>
              <li><strong>Search:</strong> O(k), where k is prefix length</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Faster product discovery improves user satisfaction</li>
              <li>Higher conversion rates through smart recommendations</li>
              <li>Improved engagement and lower bounce rate</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/trie.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Trie Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.3 Ranking Product Search Results
          </div>
          <div class="use-case-content">
            <p>
              When users search for products, Amazon must display the most
              relevant results based on multiple factors like price, reviews,
              popularity, and relevance. Ensuring that these results are sorted
              quickly and accurately is crucial for a seamless user experience
              and increased sales.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Sorting millions of products in real time</li>
              <li>Handling nearly sorted datasets efficiently</li>
              <li>Ensuring stable order for tied values</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="system-design/tim.jpg"
                alt="Time complexity visualization"
                style="
                  width: 70%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 6: Flowchart of Amazon's Product Search Ranking
              </figcaption>
            </figure>

            <h5>Algorithm: Tim sort</h5>
            <p>
              Tim Sort is a hybrid sorting algorithm derived from Merge Sort and
              Insertion Sort. It is designed to perform exceptionally well on
              real-world data by identifying and merging pre-sorted segments in
              the dataset.
            </p>
            <h5>Design Principles:</h5>
            <ul>
              <li>Divide and Conquer</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/timsort.gif"
                alt="Timsort Algorithm Visualization"
                style="
                  width: 50%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 7: Tim sort Visualization [13]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              When a customer searches for
              <strong>"wireless headphones"</strong>, the system retrieves
              millions of results. Since data is often partially ordered (e.g.,
              by previous search patterns), Tim Sort takes advantage of these
              runs to quickly sort products by relevance, price, or reviews —
              delivering fast, stable, and consistent rankings.
            </p>

            <h5>Algorithm Performance Analysis:</h5>

            <p>Time Complexity:</p>
            <ul>
              <li>Best Case: O(n) (on nearly sorted data)</li>
              <li>Average & Worst Case: O(n log n)</li>
            </ul>

            <p>Space Complexity:</p>
            <ul>
              <li>O(n) – needed for merging runs</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Improved search speed and result quality</li>
              <li>Higher user satisfaction and conversion rates</li>
              <li>Consistent and predictable ranking behavior</li>
              <li>Optimized resource usage</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/tim_sort.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Tim Sort Code on GitHub</a
            >
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.4 Visual Search Recommendation System Using KD-Tree
          </div>
          <div class="use-case-content">
            <p>
              Amazon’s visual search allows users to upload an image and
              discover similar products instantly. The system extracts visual
              features using deep learning and matches them against a vast
              product catalog using high-dimensional embeddings. This enables
              intuitive product discovery, especially when users don’t know the
              exact keywords to search for.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>
                Efficient nearest-neighbor search in high-dimensional space
              </li>
              <li>Real-time query resolution for instant user feedback</li>
              <li>Scalability across millions of product embeddings</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="system-design/kd-tree.jpg"
                alt="KD-Tree structure"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 8: Workflow of Amazon's Visual Search System Using
                KD-Tree
              </figcaption>
            </figure>

            <h5>Algorithm: KD-Tree</h5>
            <p>
              KD-Tree (k-dimensional tree) is a binary space-partitioning
              structure optimized for organizing and searching multidimensional
              data. It prunes large portions of the space during nearest
              neighbor queries by applying axis-aligned splits at each level,
              reducing computation time significantly.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>Divide-and-conquer</li>
              <li>Recursive space partitioning</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/kD-tree_02.gif"
                alt="KD-Tree animation"
                style="
                  width: 45%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 9:KD-Tree Search Visualization[14]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              <strong>Scenario:</strong> A customer uploads an image of sneakers
              to Amazon’s visual search.
            </p>
            <p>
              <strong>Process:</strong> The system uses a Convolutional Neural
              Network (CNN) to extract a high-dimensional embedding of the
              image. This vector is then queried against a KD-Tree built on
              millions of product embeddings. The tree efficiently locates and
              returns the top visually similar products — all in real time.
            </p>

            <h5>Algorithm Performance Analysis:</h5>
            <ul>
              <li><strong>Construction Time:</strong> O(n log n)</li>
              <li><strong>Average Search Time:</strong> O(log n)</li>
              <li><strong>Worst-Case Search Time:</strong> O(n)</li>
              <li><strong>Space Complexity:</strong> O(n)</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Enhances user experience with accurate visual matching</li>
              <li>Drives conversions by simplifying product discovery</li>
              <li>Scales efficiently across categories and geographies</li>
            </ul>

            <h5>Sample Code:</h5>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/kd_tree.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View KD-Tree Code on GitHub
            </a>

            <!-- Optional: Add a code snippet here or link to KD-Tree visualizer -->
            <!-- Optional: Include a basic image or flowchart for visual explanation -->
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.5 Influence-Based Ranking in Product Recommendations
          </div>
          <div class="use-case-content">
            <p>
              Amazon's recommendation engine suggests products to users based on
              their interests, browsing behavior, and interaction history. By
              analyzing a user’s purchase activity, viewed items, and patterns
              observed across similar users, the system identifies and ranks
              relevant products. It also considers item-to-item relationships
              like co-purchase trends and frequently bought together products.
            </p>
            <h5>Challenges</h5>
            <ul>
              <li>Over-representation of popular products in rankings</li>
              <li>
                Difficulty in computing rankings over massive product graphs
              </li>
              <li>Lack of data for new or less-known products</li>
            </ul>

            <figure style="text-align: center">
              <img
                src="system-design/pagerank.jpg"
                alt="PageRank Algorithm Illustration"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 10:Workflow of Influence-Based Ranking in Product
                Recommendations
              </figcaption>
            </figure>

            <h5>Algorithm: PageRank</h5>
            <p>
              PageRank ranks nodes (products) in a graph by simulating a random
              walk through the network, calculating the steady-state probability
              of landing on each node. It iteratively updates rank scores until
              convergence, reflecting each product's importance based on its
              connections.
            </p>
            <h5>Design principles:</h5>
            <ul>
              <li>Graph Traversal</li>
              <li>Iteration</li>
              <li>
                Hashing (for efficient storage and lookup in graph structures)
              </li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/Page_rank_animation.gif"
                alt="PageRank Algorithm"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 11: Visualization of the PageRank Algorithm[15]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example</h5>
            <p>
              <strong>Scenario:</strong> A customer views a smartphone product
              page.
            </p>
            <p>
              Amazon represents its product catalog as a graph where each
              product is a node, and edges reflect interactions like views,
              purchases, or co-purchases. PageRank calculates influence scores
              to:
            </p>
            <ul>
              <li>
                Suggest top-ranked products with high user interest and
                engagement
              </li>
              <li>
                Dynamically adapt recommendations based on user behavior changes
              </li>
            </ul>

            <h5>Algorithm Performance Analysis</h5>
            <p><strong>Time Complexity:</strong></p>
            <ul>
              <li>Per Iteration: O(N + E)</li>
              <li>Total (with I iterations): O((N + E) × I)</li>
            </ul>

            <p><strong>Space Complexity:</strong></p>
            <ul>
              <li>O(N + E) – to store the graph structure and rank scores</li>
            </ul>
            <h5>Market Benefits</h5>
            <ul>
              <li>Better recommendations and sales</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/page_rank.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View PageRank Code on GitHub</a
            >
          </div>
        </div>
        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.6 Customer Clustering for Personalized Product Recommendations
          </div>
          <div class="use-case-content">
            <p>
              On Amazon’s large-scale e-commerce platform, millions of customers
              make purchases every day. By identifying and clustering users who
              share similar purchasing patterns, Amazon can deliver highly
              targeted and relevant product recommendations.
            </p>
            <ul>
              <li>
                Improve personalization by recommending products frequently
                bought by similar users
              </li>
              <li>Enhance the accuracy of collaborative filtering systems</li>
              <li>
                Boost customer satisfaction through behavior-driven suggestions
              </li>
            </ul>
            <h5>Challenges:</h5>
            <ul>
              <li>Efficient clustering at scale with millions of users</li>
              <li>Real-time adaptation to changing user behavior</li>
              <li>Low latency for instant recommendations</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="system-design/union.jpg"
                alt="Union-Find Data Structure"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 12: Workflow of Customer Clustering for Personalized
                Product Recommendations
              </figcaption>
            </figure>

            <h5>Algorithm: Union-Find</h5>
            <p>
              The Union-Find data structure maintains and merges disjoint user
              groups efficiently. It supports two key operations—<code
                >union()</code
              >
              to merge clusters and <code>find()</code> to locate the
              representative of a cluster—optimized with path compression and
              union by rank for near-constant-time performance.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>Efficient set merging and lookup</li>
              <li>Path compression for fast find</li>
              <li>Union by rank for shallow trees</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/UnionFindKruskalDemo.gif"
                alt="Union-Find Kruskal's Algorithm Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 13: Visulization of union & find algorithm[16]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              <strong>Scenario:</strong> User A and User B have an 85% overlap
              in their purchase history.
            </p>
            <p>
              The system uses <code>union()</code> to group them into the same
              cluster. When User A buys a new product, <code>find()</code> is
              used to locate their cluster and recommend items recently
              purchased by similar users, such as User B.
            </p>
            <p>
              This approach supports scalable and personalized recommendation
              delivery based on real-time user clustering.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                find(x): Nearly constant time O(α(n)) with path compression
              </li>
              <li>
                union(x, y): Nearly constant time O(α(n)) with union by rank
              </li>
              <li>Space Complexity: O(n), where n is the number of users</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Improved customer retention via personalized experiences</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/Union-Find.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Union-Find Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.7 Efficient Range Query Analysis in Purchase Logs
          </div>
          <div class="use-case-content">
            <p>
              An e-commerce platform logs all product purchases over time.
              Business analysts frequently ask:
              <strong
                >“Which product was purchased the most between time X and
                Y?”</strong
              >
              These queries are crucial for trend discovery, inventory control,
              and promotional campaigns.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Efficient processing of range queries</li>
              <li>Reducing redundant computations</li>
              <li>Scalable for static historical data</li>
            </ul>

            <figure style="text-align: center">
              <img
                src="system-design/mo.jpg"
                alt="Mo's Algorithm Illustration"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 14: Workflow of Efficient Range Query Analysis on
                Purchase Logs
              </figcaption>
            </figure>

            <h5>Algorithm: Mo's Algorithm</h5>
            <p>
              Mo’s Algorithm efficiently answers multiple range queries on
              static arrays by sorting queries to minimize pointer movements,
              reducing redundant computations.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>Query Sorting</li>
              <li>Block Decomposition</li>
              <li>Two-Pointer Technique</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/mo's.jpg"
                alt="Mo's Algorithm Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 15: Mo's Algorithm Visulization[17]
              </figcaption>
            </figure>

            <h5>Real-Time Usage</h5>
            <p>
              Suppose analysts want to know which product sold the most between
              timestamps 1,000 and 5,000 in a large purchase log of millions of
              entries. Instead of scanning the entire range for each query, Mo’s
              Algorithm sorts and processes multiple such queries in an order
              that minimizes data movement. This drastically reduces redundant
              work, enabling near real-time answers for multiple range queries
              on historical purchase data — powering fast, interactive
              dashboards for inventory and marketing teams.
            </p>
            <h5>Algorithm Performance Analysis</h5>

            <p>Time Complexity:</p>
            <ul>
              <li>Per Query: O(√N) amortized</li>
              <li>Total Time (for Q queries): O((N + Q) × √N)</li>
            </ul>

            <p>Space Complexity:</p>
            <ul>
              <li>
                O(N + M) – N is array size, M is number of unique product IDs
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Real-time analytics enable smarter decisions</li>
              <li>Optimized inventory and targeted promotions</li>
              <li>Reduced computational cost and faster reports</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/mos.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Mo's Code on GitHub</a
            >
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.8 Intelligent Order Fulfillment Priority Management
          </div>
          <div class="use-case-content">
            <p>
              In modern e-commerce fulfillment centers, thousands of orders
              arrive continuously with varying delivery commitments. The system
              must intelligently prioritize order processing to meet Service
              Level Agreements (SLAs), optimize resource allocation, and
              maintain high customer satisfaction ratings.
            </p>
            <h5>Challenges</h5>
            <ul>
              <li>Maintaining order sequence.</li>
              <li>Prioritizing urgent orders.</li>
              <li>Efficiently processing large volumes.</li>
            </ul>

            <!-- <img
              src="system-design/pagerank.jpg"
              width="100%"
              height="600px"
              style="border: none"
            /> -->

            <h5>Algorithm: Priority Queue with Dynamic Scheduling</h5>

            <p>
              Implements a sophisticated priority queue system using min-heap
              data structure where orders are prioritized based on delivery
              deadlines, service tier, and processing time requirements.
            </p>

            <figure style="text-align: center">
              <img
                src="gif/cart.gif"
                alt="Cart Algorithm Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 16: Priority Queue Visulization
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example</h5>
            <p>
              During Black Friday peak hours, the fulfillment center receives
              10,000 orders per hour with mixed delivery commitments.
            </p>
            <p>
              Orders are automatically sorted by deadline urgency. Same-day
              orders (2-hour deadline) are processed immediately, next-day
              orders maintain their SLA, and standard orders fill processing
              gaps efficiently. This approach increases on-time delivery rates
              from 78% to 96% while reducing emergency shipping costs by 40%.
            </p>
            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                <strong>Order Insertion:</strong> Time – O(log n), Space – O(1)
              </li>
              <li><strong>Priority Extraction:</strong> Time – O(log n)</li>
              <li><strong>Priority Update:</strong> Time – O(log n)</li>
              <li>
                <strong>Batch Processing:</strong> Time – O(n log n), Space –
                O(n)
              </li>
            </ul>

            <h5>Market Benefits</h5>
            <ul>
              <li>Improved customer satisfaction.</li>
              <li>Faster delivery of urgent orders.</li>
              <li>Lower operational costs.</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/cart.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Priority Queue Code on GitHub</a
            >
          </div>
        </div>
        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            1.9 Smart Shopping Cart Management with Undo/Redo Operations
          </div>
          <div class="use-case-content">
            <p>
              E-commerce customers frequently modify their shopping carts by
              adding, removing, or changing item quantities. Providing intuitive
              undo/redo functionality allows users to easily revert or reapply
              changes, enhancing shopping experience and reducing cart
              abandonment.
            </p>
            <!-- <img
              src="system-design/segment.jpg"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            /> -->
            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>State Tracking:</strong> Efficient cart history
                management.
              </li>
              <li>
                <strong>Accurate Reversal:</strong> Reliable undo/redo
                operations.
              </li>
              <li>
                <strong>Memory Control:</strong> Avoiding memory overload.
              </li>
            </ul>

            <h5>
              Algorithm : Stack-Based Command Pattern with State Management
            </h5>
            <p>
              The algorithm encapsulates cart operations (Add, Remove, Update
              Quantity) as command objects with
              <code>execute()</code> and <code>undo()</code> methods. It
              maintains two stacks: the undo stack for executed commands and the
              redo stack for undone commands. When a new command is executed,
              the redo stack is cleared to maintain consistency. Periodic state
              snapshots compress the history to optimize memory use. This design
              follows the Command Pattern and ensures O(1) time complexity for
              undo/redo operations.
            </p>

            <!-- <figure style="text-align: center">
              <img
                src="gif/knapsack_tabulation.gif"
                alt="Knapsack Algorithm Tabulation Visualization"
                style="
                  width: 45%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 1: Amazon eCommerce System Design Architecture
              </figcaption>
            </figure> -->

            <h5>Real-Time Usage Example:</h5>
            <p>
              A shopper adds multiple electronics items over a 30-minute
              session, frequently adjusting quantities and removing items.
              Without undo/redo, accidental removals cause frustration and cart
              abandonment. With smart cart management, the shopper easily undoes
              an accidental removal of a laptop bundle, preserving their cart
              setup and completing the purchase, resulting in higher
              satisfaction and retention.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                <strong>Execute:</strong> O(1) time/space; quick command run.
              </li>
              <li><strong>Undo/Redo:</strong> O(1); fast stack operations.</li>
              <li>
                <strong>Snapshot:</strong> O(n); occasional full cart save.
              </li>
              <li>
                <strong>Cleanup:</strong> O(k); trims old commands to save
                memory.
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Fewer Abandoned Carts:</strong> Up to 15% drop in exits.
              </li>
              <li>
                <strong>User Confidence:</strong> Encourages flexible cart
                edits.
              </li>
              <li><strong>Higher Sales:</strong> Smoother checkout flow.</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/knapsack.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Code on GitHub</a
            >
          </div>
        </div>
        <h3>2. Amazon Logistics & Delivery Use Cases</h3>
        <figure style="text-align: center">
          <img
            src="system-design/logistic.jpg"
            width="100%"
            height="600px"
            style="border: none"
            alt="Amazon Logistics and Supply Chain System Design"
          />
          <figcaption style="margin-top: 8px; font-style: italic; color: #555">
            Figure 17: Amazon Logistics and Supply Chain System Design
          </figcaption>
        </figure>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            2.1 Inventory Management and Stock Allocation
          </div>
          <div class="use-case-content">
            <p>
              Effective inventory management is vital for Amazon to ensure
              product availability while minimizing excess stock and storage
              costs. With millions of products and distributed warehouses,
              Amazon employs intelligent systems that consider warehouse
              capacity, regional demand, and shipping efficiency to optimize
              stock allocation, reduce delivery times, and enhance operational
              efficiency.
            </p>
            <!-- <img
              src="system-design/segment.jpg"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            /> -->
            <h5>Challenges:</h5>
            <ul>
              <li>
                Managing large-scale inventory with limited warehouse space
              </li>
              <li>Balancing product value against storage constraints</li>
            </ul>

            <h5>Algorithm : 0/1 Knapsack</h5>
            <p>
              The 0/1 Knapsack algorithm uses dynamic programming to select a
              subset of items that maximizes total value without exceeding a
              capacity limit. Each item can either be included or excluded (0 or
              1). It builds a table to store optimal solutions for subproblems
              based on item count and capacity.
            </p>

            <h5>Design Principle:</h5>
            <ul>
              <li>Dynamic Programming</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/knapsack_tabulation.gif"
                alt="Knapsack Algorithm Tabulation Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 18: 0/1 Knapsack Algorithm Visulization[18]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              Amazon distributes 500 products across 3 warehouses with limited
              space. For each warehouse, the 0/1 Knapsack algorithm selects
              products to maximize value (demand × profit) while staying within
              storage limits.
            </p>
            <p>
              Example: The North warehouse has 1,000 cubic meters capacity. The
              algorithm picks high-demand, space-efficient items like
              smartphones and jackets, excluding bulky, low-demand products to
              optimize inventory and reduce delivery times.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                Time Complexity: O(N × W), where N is number of products and W
                is warehouse capacity
              </li>
              <li>
                Space Complexity: O(N × W), can be optimized to O(W) using a 1D
                array
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Reduces holding costs and stockouts</li>
              <li>
                Improves fulfillment efficiency by prioritizing high-demand
                products
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/knapsack.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View 0/1 Knapsack Code on GitHub</a
            >
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            2.2 Optimization of Warehouse and Fulfillment Center Network
          </div>
          <div class="use-case-content">
            <p>
              Amazon’s vast fulfillment center network requires efficient
              interconnections to minimize transportation costs and delivery
              times. By designing an optimized logistics network that adapts to
              demand fluctuations and real-world conditions, Amazon reduces
              expenses, improves delivery speed, and ensures scalable,
              cost-effective operations.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>
                Changing demand regions may require dynamic MST adjustments
              </li>
              <li>Complex edge weights due to terrain and traffic factors</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="system-design/mst.jpg"
                alt="Minimum Spanning Tree Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 19: Workflow for Optimization of Warehouse and
                Fulfillment Center Networks
              </figcaption>
            </figure>

            <h5>Algorithm: Kruskal’s</h5>

            <p>
              A greedy method that sorts all edges by weight and adds the
              smallest edge to the MST if it does not create a cycle, using
              Union-Find to detect cycles.
            </p>
            <h5>Design Principles:</h5>
            <ul>
              <li>Greedy selection of smallest edges</li>
              <li>Cycle detection with Union-Find</li>
              <li>Connects disjoint sets to build MST</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/kruskals.gif"
                alt="Kruskal's Algorithm in Action"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 20: Kruskal's Algorithm Visulization[19]
              </figcaption>
            </figure>

            <h5>Algorithm: Prim’s</h5>
            <p>
              Starts from a source node and grows the MST by repeatedly adding
              the smallest edge connecting the tree to a new vertex, typically
              implemented with a priority queue.
            </p>
            <h5>Design Principles:</h5>
            <ul>
              <li>Greedy expansion from a starting node</li>
              <li>Priority queue for efficient edge selection</li>
              <li>Grows MST by connecting closest vertices</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/prims.gif"
                alt="Prim's Algorithm in Action"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 21: Prims Algorithm Visulization
              </figcaption>
            </figure>

            <h5>Real-Time Usage :</h5>
            <p>
              Amazon plans to open 10 new fulfillment centers connected by
              routes with varying costs. Using
              <strong>Kruskal’s Algorithm</strong>, routes are sorted by cost to
              connect all centers with minimal total expense, avoiding loops.
              <strong>Prim’s Algorithm</strong> starts from a key hub and
              expands by linking the nearest centers, ideal for phased growth.
            </p>
            <p>
              <strong>Example:</strong> If routes between centers A-B, A-C, and
              B-C cost $5, $10, and $7 respectively, Kruskal’s algorithm picks
              A-B and B-C for a total cost of $12, avoiding the costly A-C
              route.
            </p>
            <h5>ALgorithm performance Analysis</h5>
            <div
              style="display: flex; justify-content: center; margin-top: 20px"
            >
              <table
                border="1"
                cellpadding="10"
                cellspacing="0"
                style="border-collapse: collapse; text-align: center"
              >
                <thead>
                  <tr>
                    <th>Aspect</th>
                    <th>Kruskal’s Algorithm</th>
                    <th>Prim’s Algorithm</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Time Complexity</td>
                    <td>O(E log E)</td>
                    <td>O(E + V log V)</td>
                  </tr>
                  <tr>
                    <td>Space Complexity</td>
                    <td>O(V + E)</td>
                    <td>O(V + E)</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Reduces inter-warehouse transportation cost</li>
              <li>Boosts delivery speed through efficient route planning</li>
              <li>Builds scalable and cost-effective logistics networks</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/kruskal.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Kruskal's Code Here</a
            >
            <br />
            <!-- Prim's Algorithm -->
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/prims.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Prim's Code Here</a
            >
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            2.3 Warehouse Robot Navigation
          </div>
          <div class="use-case-content">
            <p>
              Amazon’s robotic fulfillment centers deploy autonomous robots to
              transport items between storage shelves and packing stations. The
              warehouse floor is divided into cells, each with varying movement
              costs depending on factors such as aisle width, floor conditions,
              or congestion. Unlike traditional shortest path algorithms, the
              goal is to find the path that minimizes total energy consumption
              or movement cost rather than just distance.
            </p>
            <!-- <img
              src="system-design/segment.jpg"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            /> -->

            <h5>Challenges:</h5>
            <ul>
              <li>
                Variable movement costs per cell (energy cost differences)
              </li>
              <li>No reliable heuristics for real-time path costs</li>
              <li>Finding energy-efficient (least-cost) routes</li>
              <li>Scalability for many robots navigating simultaneously</li>
            </ul>

            <h5>Algorithm: Uniform Cost Search (UCS)</h5>
            <p>
              Uniform Cost Search (UCS) is a graph traversal algorithm that
              expands the least-cost node first. It uses a priority queue to
              explore paths based on cumulative path cost, ensuring an optimal
              solution when all step costs are non-negative.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>Expands paths with the lowest cumulative cost first</li>
              <li>Uses a priority queue for efficient node selection</li>
              <li>Guarantees optimal path if all costs are non-negative</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/ucs.gif"
                alt="Uniform Cost Search Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 22: Uniform Cost Search Algorithm Visulization[20]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              In an Amazon warehouse, robots navigate aisles with different
              movement costs — for example, narrow aisles require more energy to
              maneuver than wide ones. Using
              <strong>Uniform Cost Search (UCS)</strong>, robots find the least
              energy-consuming path rather than just the shortest distance.
            </p>
            <p>
              <strong>Example:</strong> Suppose a robot must move from point A
              to D. The direct path A→D is shortest but passes through a narrow
              aisle costing 5 energy units. An alternative path A→B→C→D is
              longer but costs only 2 energy units per segment. UCS chooses the
              longer but less costly route to save battery life and improve
              efficiency.
            </p>

            <!-- Analysis Section -->

            <h5>Uniform Cost Search: Algorithm Performance Analysis</h5>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(b<sup>1 + C*/ε</sup>),
                where:
                <ul>
                  <li><code>b</code> = branching factor</li>
                  <li><code>C*</code> = cost of the optimal solution</li>
                  <li><code>ε</code> = minimum positive edge cost</li>
                </ul>
                UCS explores all nodes with cumulative path cost ≤ C*, which
                leads to exponential growth.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(b<sup>1 + C*/ε</sup>),
                because it keeps all generated nodes in memory (open and closed
                lists).
              </li>
              <li>
                <strong>Optimality:</strong> Guaranteed (if costs are
                non-negative).
              </li>
              <li>
                <strong>Completeness:</strong> Yes, if the branching factor is
                finite and step costs are ≥ ε > 0.
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Saves energy and extends robot battery life</li>
              <li>Speeds up order fulfillment with efficient routing</li>
              <li>Reduces robot wear and tear</li>
              <li>Supports scaling robotic fleets efficiently</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/ucs.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View UCS Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            2.4 Stable Driver–Warehouse Matching During Prime Day
          </div>
          <div class="use-case-content">
            <p>
              During major sales events like Prime Day, Amazon must efficiently
              match thousands of delivery drivers to dozens of warehouses. Each
              driver has preferences (e.g., closer locations, preferred shift
              times), while warehouses prioritize drivers based on factors like
              availability and experience.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                Managing large-scale driver–warehouse assignments in real time
              </li>
              <li>Ensuring fair and mutually beneficial matches</li>
              <li>Producing results quickly to prevent delivery delays</li>
            </ul>

            <h5>Algorithm: Gale-Shapley Stable Matching Algorithm</h5>
            <p>
              The Gale–Shapley algorithm assigns drivers to warehouses based on
              mutual preferences. Drivers sequentially propose to their most
              preferred warehouse. Warehouses tentatively accept the most
              suitable offer (based on their preferences) while rejecting
              others. This continues until all drivers are matched, ensuring no
              unmatched pair would prefer each other over their current match.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>Drivers propose based on ranked preferences</li>
              <li>
                Warehouses accept best-fit offers (tentative until better comes)
              </li>
              <li>Stable matches ensure no driver-warehouse would swap</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/stable marriage.gif"
                alt="Stable Marriage Algorithm Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 23: Gale-Shapley Stable Matching Algorithm
                Visulization[21]
              </figcaption>
            </figure>

            <h5>Real-Time Usage :</h5>
            <p>
              During Prime Day, Amazon needs to assign drivers to warehouses
              efficiently. Suppose there are 5 drivers and 5 warehouses, each
              with their own ranked preferences based on factors like distance,
              shift times, availability, and experience.
            </p>
            <p>
              Using the <strong>Gale-Shapley algorithm</strong>, drivers propose
              to their preferred warehouses in order. Warehouses tentatively
              accept the best proposals based on their preferences, rejecting
              less preferred offers. This process continues until all drivers
              and warehouses are matched in a way that no pair would prefer
              switching partners.
            </p>
            <p>
              For example, Driver D1 prefers Warehouse W3 first, but if W3
              prefers another driver D2 more, W3 will tentatively reject D1’s
              proposal and wait for a better match, ensuring stable assignments
              that optimize satisfaction and reduce reassignments during busy
              times.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>Time Complexity: O(n²) for n drivers and warehouses</li>
              <li>Space Complexity: O(n + m) for storing preferences</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>
                Minimizes reassignments and confusion during high-demand periods
              </li>
              <li>Improves driver satisfaction through fair matching</li>
              <li>Enables faster, more reliable deliveries</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/gale_shapely.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Code on GitHub</a
            >
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            2.5 Delivery Route Planning
          </div>
          <div class="use-case-content">
            <p>
              Amazon uses intelligent route planning systems to optimize
              last-mile delivery through autonomous ground robots like Scout and
              other delivery vehicles. These systems must handle dynamic city
              environments and unpredictable real-time conditions while ensuring
              timely deliveries.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>
                Real-time rerouting due to traffic congestion, roadblocks, or
                construction
              </li>
              <li>
                Managing route constraints such as one-way streets and temporary
                detours
              </li>
              <li>
                Optimizing routes based on energy constraints, load weight, and
                deadlines
              </li>
            </ul>

            <figure style="text-align: center">
              <img
                src="system-design/Astar1.jpg"
                alt="A* Algorithm Visualization"
                style="
                  width: 30%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 24: Delivery Route Planning Workflow
              </figcaption>
            </figure>

            <h5>Algorithm: A* Tree</h5>
            <p>
              A* finds the shortest path in a weighted graph by combining the
              actual cost from the start and a heuristic estimate to the goal.
            </p>
            <p><strong>f(n) = g(n) + h(n)</strong>, where:</p>
            <ul>
              <li><strong>g(n)</strong> = cost from start to current node</li>
              <li><strong>h(n)</strong> = heuristic estimate to goal</li>
            </ul>
            <h5>Design Principles:</h5>
            <ul>
              <li>Heuristic Guidance: Prioritizes nodes nearer to the goal.</li>
              <li>
                Optimality: Guarantees shortest path with admissible heuristic.
              </li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/AstarExampleEn.gif"
                alt="A* Algorithm Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 25: Visualization of the A* Pathfinding Algorithm[22]
              </figcaption>
            </figure>

            <h5>Real-Time Usage:</h5>
            <p>
              In last-mile delivery operations, A* helps Scout robots and
              delivery vehicles efficiently plan and adapt routes across urban
              grids and residential zones.
            </p>
            <p>
              <strong>Example:</strong> A delivery robot handling five orders in
              a neighborhood might face:
            </p>
            <ul>
              <li>
                Road closures or construction blocking access to certain streets
              </li>
              <li>
                Energy constraints requiring the most power-efficient route
              </li>
              <li>
                Temporary loss of GPS signal; fallback paths are estimated using
                historical delivery data
              </li>
              <li>
                The robot instantly recalculates the path using A*, ensuring
                minimal delay
              </li>
            </ul>

            <h5>Real-Time Heuristics Considered:</h5>
            <ul>
              <li>
                <strong>Traffic Time Estimate:</strong> Adjusts path cost based
                on congestion data
              </li>
              <li>
                <strong>Energy Efficiency:</strong> Avoids steep paths or longer
                detours to conserve power
              </li>
              <li>
                <strong>Delivery Deadlines:</strong> Prioritizes deliveries
                nearing SLA time limits
              </li>
            </ul>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                Time Complexity: O(b<sup>d</sup>), where b is branching factor
                and d is depth; can be high in 3D space
              </li>
              <li>
                Space Complexity: O(V), where V is number of nodes or grid
                points
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>
                Faster and more reliable deliveries with optimized route
                computation
              </li>
              <li>
                Reduced operational costs by minimizing travel time and distance
              </li>
              <li>
                Improved customer satisfaction through consistent on-time
                performance
              </li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/A*tree.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View A* Code on GitHub</a
            >
          </div>
        </div>
        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            2.6 Smart Aerial Logistics Optimization System(Amazon Prime Air –
            Drone Delivery)
          </div>
          <div class="use-case-content">
            <p>
              A drone-based delivery system designed to deliver packages in
              under 30 minutes using AI-powered autonomous drones. The system
              dynamically plans flight routes, avoids obstacles, and optimizes
              for time and energy usage.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                Real-time route planning avoiding no-fly zones and obstacles
              </li>
              <li>Battery-efficient path optimization</li>
              <li>Dynamic route recalculation due to changing conditions</li>
            </ul>

            <h5>Algorithm :A* tree</h5>
            <p>
              The A* algorithm is a popular pathfinding and graph traversal
              algorithm that finds the shortest path between nodes in a weighted
              graph. It combines features of Dijkstra's algorithm and Greedy
              Best-First Search by using both the actual cost from the start
              node and an estimated cost to the goal to guide the search
              efficiently.
            </p>

            <p>It uses a cost function:</p>
            <p><strong>f(n) = g(n) + h(n)</strong>, where:</p>
            <ul>
              <li>
                <strong>g(n)</strong> = actual cost from the start node to the
                current node
              </li>
              <li>
                <strong>h(n)</strong> = heuristic estimated cost from the
                current node to the goal
              </li>
            </ul>
            <!-- <img
              src="system-design/segment.jpg"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            /> -->
            <h5>Design Principles:</h5>
            <ul>
              <li>Heuristic Guidance: Prioritizes nodes closer to the goal.</li>
              <li>
                Optimality: Ensures shortest path with an admissible heuristic.
              </li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/AstarExampleEn.gif"
                alt="A* Algorithm Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 26: Animated Visualization of the A* Pathfinding[22]
                Algorithm
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example with Heuristics</h5>
            <p><strong>Scenario:</strong></p>
            <ul>
              <li>
                An Amazon Prime Air drone must deliver a package 10 km away in a
                city.
              </li>
              <li>During the flight, it faces no-fly zones near hospitals.</li>
              <li>Sudden wind changes occur.</li>
              <li>Low battery triggers route optimization.</li>
              <li>Unexpected obstacles like cranes appear.</li>
            </ul>

            <p><strong>How A* Helps:</strong></p>
            <ul>
              <li>
                Models the 3D airspace as a grid graph (latitude, longitude,
                altitude).
              </li>
              <li>
                Uses Euclidean distance as the heuristic to estimate
                straight-line distance to the goal.
              </li>
              <li>
                Adds environmental penalties in the heuristic for obstacles or
                weather conditions to avoid risky paths.
              </li>
              <li>
                Dynamically recalculates the route to avoid no-fly zones and
                conserve battery.
              </li>
            </ul>
            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                Time Complexity: O(b<sup>d</sup>), where b is branching factor
                and d is depth; can be high in 3D space
              </li>
              <li>
                Space Complexity: O(V), where V is number of nodes or grid
                points
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Ultra-fast, reliable delivery</li>
              <li>Reduced last-mile delivery costs</li>
              <li>Access to remote and urban areas with complex navigation</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/A*tree.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View A* Code on GitHub</a
            >
          </div>
        </div>

        <h3>3. Amazon Pay & Security Use Case</h3>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            3.1 Secure Payment Encryption (Amazon Pay)
          </div>
          <div class="use-case-content">
            <p>
              <strong>Problem:</strong> Encrypting customer card information
              quickly and securely during high-volume events like Prime Day.
            </p>
            <p>
              <strong>How FLT Helps:</strong> Fermat's Little Theorem optimizes
              modular arithmetic used in encryption algorithms like RSA, making
              encryption and decryption faster.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>Handling high-volume transactions efficiently</li>
              <li>Balancing encryption speed and security</li>
              <li>Real-time encryption without delays</li>
            </ul>

            <h5>Algorithm: RSA (with FLT Optimization)</h5>

            <p>
              RSA is a public-key encryption method using a public-private key
              pair. Fermat’s Little Theorem (FLT) speeds up modular inverse
              calculations during key generation and decryption.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>Use large primes to generate public-private key pairs</li>
              <li>Apply Fermat’s Little Theorem for fast modular inverse</li>
              <li>Encrypt with public key, decrypt with private key</li>
            </ul>

            <h5>Real-Time Usage Example:</h5>
            <p>
              During Prime Day, thousands of customers make purchases
              simultaneously. To protect sensitive card information, Amazon Pay
              encrypts the AES session key using RSA with Fermat’s Little
              Theorem optimization. For example, when a customer completes a
              transaction, RSA quickly encrypts the session key so only Amazon’s
              secure servers can decrypt it. This speeds up encryption and
              decryption, ensuring secure payments without slowing checkout
              during peak traffic.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                Time Complexity: O(n³), improved in practice with FLT
                optimization
              </li>
              <li>Space Complexity: O(n) for key storage</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>
                Faster, secure transactions during peak loads (e.g., Prime Day)
              </li>
              <li>Scalable encryption handling large transaction volumes</li>
              <li>Enhanced customer trust through strong data protection</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/flt.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View FLT Code on GitHub</a
            >

            <!-- <img
              src="https://media.giphy.com/media/ToMjGpS8DH4LEYhQ3qU/giphy.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            /> -->
          </div>
        </div>
        <h3>4. AWS use cases</h3>
        <figure style="text-align: center">
          <img
            src="system-design/aws.jpg"
            width="100%"
            height="650px"
            style="border: none"
            alt="AWS Architecture Diagram for Amazon Systems"
          />
          <figcaption style="margin-top: 8px; font-style: italic; color: #555">
            Figure 27: AWS System Design Architecture [7]
          </figcaption>
        </figure>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            4.1 Dynamic Resource Load Detection Using AWS CloudWatch
          </div>
          <div class="use-case-content">
            <p>
              Analyzing CPU, memory, and I/O usage patterns across EC2 instances
              and time windows to detect sustained high-load zones in near
              real-time using AWS CloudWatch metrics .
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Detecting real-time high-load zones (spikes) efficiently</li>
              <li>Processing large 2D data matrices continuously</li>
              <li>Scalability for monitoring multiple servers over time</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="system-design/2d.jpg"
                alt="2D Visualization"
                style="
                  width: 30%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 28: Workflow for Dynamic Resource Load Detection Using
                AWS CloudWatch
              </figcaption>
            </figure>

            <h5>Algorithm: 2D Kadane</h5>
            <p>
              Modified 2D Kadane's Algorithm identifies submatrices where
              resource usage consistently exceeds dynamic thresholds. Unlike
              standard maximum sum detection, this variant focuses on sustained
              load patterns above baseline performance metrics.
            </p>
            <h5>Design Principles:</h5>
            <ul>
              <li>Compress columns into 1D row sums</li>
              <li>Apply Kadane’s Algorithm on row sums</li>
              <li>Scan all column pairs for best submatrix</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/2dkadane.gif"
                alt="2D Kadane's Algorithm Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 29: 2D_Kadane Algorithm Visulization
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              <strong>Scenario:</strong> E-commerce platform monitoring 500 EC2
              instances during Black Friday traffic surge. CloudWatch collects
              CPU/memory metrics every 30 seconds, creating a 500×2880 matrix
              (instances × 24-hour periods).
            </p>

            <p>
              <strong>Algorithm Application:</strong> The enhanced 2D Kadane
              detects a critical submatrix: 25 instances experiencing 85%+ CPU
              utilization for 12+ consecutive minutes in the checkout
              microservice cluster. This pattern indicates impending service
              degradation requiring immediate scaling.
            </p>

            <p>
              <strong>Automated Response:</strong> Upon detection, the system
              triggers: AWS Auto Scaling Group expansion, CloudWatch alarm
              escalation, and load balancer traffic redistribution - preventing
              customer-facing outages before they occur.
            </p>
            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>Time Complexity: O(n³) for n×n matrices</li>
              <li>Space Complexity: O(n)</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Faster anomaly detection enabling smart autoscaling</li>
              <li>Improved service reliability and reduced downtime</li>
              <li>Operational cost savings through efficient resource use</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/2D_Kadane.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View 2D_Kadane Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            4.2 Efficient Resource Usage Monitoring in AWS Cloud
          </div>
          <div class="use-case-content">
            <p>
              AWS CloudWatch processes millions of metric queries daily for
              dashboards, alerting, and operational analytics. Enterprise
              customers frequently query resource usage patterns across custom
              time ranges (last 6 hours, peak traffic windows, incident
              timeframes) requiring sub-second response times for real-time
              operational decision making.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Frequent interval-based queries with low latency</li>
              <li>
                Handling high-frequency data from thousands of sources
                efficiently
              </li>
            </ul>

            <figure style="text-align: center">
              <img
                src="system-design/square.jpg"
                alt="Square Visualization"
                style="
                  width: 30%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 30: Workflow for Resource Usage Monitoring in AWS Cloud
              </figcaption>
            </figure>

            <h5>Algorithm: Square Root Decomposition</h5>
            <p>
              Square Root Decomposition is a technique that divides an array
              into √n-sized blocks to speed up range queries and updates.
              Instead of scanning the full range, it combines block-level
              precomputed values with partial sums for fast results.
            </p>

            <p>Design principle</p>
            <ul>
              <li>Divide array of size n into √n blocks</li>
              <li>Precompute aggregates per block</li>
              <li>Use partial + block sums for range queries</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/squareroot-decomposition.png"
                alt="Square Root Decomposition Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 31: Square Root Decomposition Algorithm[23]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              <strong>Scenario:</strong> Netflix's AWS infrastructure team needs
              to analyze CPU utilization patterns across 5,000 EC2 instances
              during a global streaming event. They query multiple custom time
              ranges: "2-4 PM peak hours," "incident window 3:15-3:45 PM," and
              "recovery period 4:00-5:00 PM."
            </p>

            <p>
              <strong>Traditional Approach:</strong> Scanning millions of
              individual metric points would require 15-30 seconds per query,
              making real-time analysis impossible during critical incidents.
            </p>

            <p>
              <strong>Optimized Solution:</strong> The adaptive square root
              decomposition pre-aggregates metrics into intelligent blocks
              (5-minute intervals for recent data, 15-minute for historical).
              Each query combines 6-12 block aggregates instead of scanning
              300,000+ individual data points, reducing response time to
              200-500ms.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>Preprocessing Time: O(n)</li>
              <li>Range Query Time: O(√n)</li>
              <li>Update Time: O(√n) worst case</li>
              <li>Space Complexity: O(n)</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Real-time billing visibility</li>
              <li>Instant anomaly detection</li>
              <li>Scalable and efficient resource monitoring</li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/sqrt_decomposition.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            4.3 AWS VPC Network Traffic Routing Optimization
          </div>
          <div class="use-case-content">
            <p>
              Enterprise AWS VPC environments with multi-tier applications
              distributed across multiple Availability Zones require
              sophisticated network analysis to optimize performance and costs.
              Web servers in public subnets must efficiently communicate with
              application servers in private subnets and database clusters in
              isolated subnets, while managing hybrid connectivity through VPN
              gateways, Direct Connect, and Transit Gateway connections.
            </p>

            <!-- <img
              src="system-design/square.jpg"
              width="100%"
              height="600px"
              style="border: none"
            /> -->
            <h5>Challenges:</h5>
            <ul>
              <li>
                Optimizing network paths between AZ-1 web servers and AZ-2
                databases.
              </li>
              <li>Reducing latency and cross-AZ data transfer costs.</li>
              <li>Preventing routing loops to avoid network failures.</li>
            </ul>

            <h5>Algorithm: Bellman-Ford</h5>
            <p>
              Bellman-Ford is a shortest path algorithm that handles negative
              edge weights, making it ideal for AWS VPC routing. It detects
              routing loops, finds optimal paths from a single source to all
              destinations, and works reliably even in complex network
              topologies.
            </p>

            <figure style="text-align: center">
              <img
                src="gif/bellmanford.gif"
                alt="Bellman-Ford Algorithm Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 32: Visulization of Bellman-Ford Algorithm[24]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p><strong>Network Setup:</strong></p>
            <ul>
              <li>
                VPC Subnets: Public (Web Tier), Private (App Tier), Database
              </li>
              <li>
                Key Components: Load balancers, app servers, RDS clusters,
                ElastiCache
              </li>
              <li>
                External Connections: VPN, Direct Connect, Transit Gateway, VPC
                Peering
              </li>
            </ul>

            <p><strong>Black Friday Scenario:</strong></p>
            <ul>
              <li>Traffic jumps from 1,000 to 50,000 requests/sec</li>
              <li>Database queries increase 20x</li>
              <li>Cross-AZ bandwidth tightens</li>
            </ul>

            <p><strong>Algorithm Steps:</strong></p>
            <ul>
              <li>Assess network: Assign weights based on latency and cost</li>
              <li>
                Run Bellman-Ford: Find optimal routes, update routing tables, no
                loops detected
              </li>
              <li>
                Dynamic rerouting: Monitor load, shift traffic to reduce AZ1
                overload and balance DB queries
              </li>
            </ul>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                <strong>Best Case:</strong> O(E) - Linear time when no negative
                cycles exist
              </li>
              <li>
                <strong>Average Case:</strong> O(V × E) - Standard performance
                for typical networks
              </li>
              <li>
                <strong>Worst Case:</strong> O(V × E) - Maximum iterations
                needed for complex topologies
              </li>
              <li>
                <strong>Space Complexity:</strong> O(V) - Memory efficient
                storage for distance arrays
              </li>
              <li>
                <strong>Practical Performance:</strong> ~100ms for typical VPC
                networks (&lt;1000 nodes)
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Reduced network operating expenses</li>
              <li>Improved application performance</li>
              <li>High network availability with intelligent failover</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/bellman-ford.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            4.4 Traffic Distribution for High Availability in AWS Load Balancing
          </div>
          <div class="use-case-content">
            <p>
              In AWS cloud environments, efficiently distributing traffic across
              heterogeneous server instances is critical for maintaining high
              availability, optimal performance, and cost-effectiveness. As
              traffic patterns fluctuate and server capacities vary
              significantly, intelligent load balancing algorithms help prevent
              bottlenecks, ensure optimal resource utilization, and maintain
              consistent user experience across diverse workloads.
            </p>
            <h5>Challenges:</h5>
            <ul>
              <li>Uneven load causing server overloads</li>
              <li>Handling varied server capacities efficiently</li>
              <li>Ensuring high availability during traffic spikes</li>
            </ul>
            <figure style="text-align: center">
              <img
                src="images/loadbalancing_w.png"
                alt="Load Balancing Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 33:Architecture diagram illustrating AWS load balancing
                for traffic distribution
              </figcaption>
            </figure>

            <h5>Algorithm: Weighted Round Robin (WRR)</h5>
            <p>
              Weighted Round Robin is an advanced load balancing algorithm that
              distributes incoming requests across multiple servers based on
              dynamically calculated weights. Each server receives traffic
              proportional to its weight, which reflects its processing
              capacity, current load, and health status. This ensures that
              high-performance servers handle proportionally more requests while
              preventing smaller instances from being overwhelmed.
            </p>

            <figure style="text-align: center">
              <img
                src="gif/wrr.gif"
                alt="Weighted Round Robin Load Balancing Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 34: Animation demonstrating the Weighted Round Robin
                (WRR) algorithm[9]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>A web app runs on 3 EC2 instances with weights:</p>
            <table>
              <thead>
                <tr>
                  <th>Server</th>
                  <th>Instance Type</th>
                  <th>Weight</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Server A</td>
                  <td>m5.large</td>
                  <td>5</td>
                </tr>
                <tr>
                  <td>Server B</td>
                  <td>t3.medium</td>
                  <td>3</td>
                </tr>
                <tr>
                  <td>Server C</td>
                  <td>t3.small</td>
                  <td>2</td>
                </tr>
              </tbody>
            </table>
            <p>
              The AWS Load Balancer distributes traffic so Server A gets 50%,
              Server B 30%, and Server C 20% of requests, matching each
              instance’s capacity and improving performance.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                Time Complexity:O(1) per request — selects the next server in
                constant time.
              </li>
              <li>
                Space Complexity: O(n) — stores weights and counters for n
                servers.
              </li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Improved uptime and reliability</li>
              <li>Cost-effective resource usage</li>
              <li>Enhanced user experience with low latency</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/wrr.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View WRR Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            4.5 Content Delivery Network Optimization in AWS CloudFront
          </div>
          <div class="use-case-content">
            <p>
              AWS CloudFront operates a global network of over 400 edge
              locations to deliver content with minimal latency. The service
              employs intelligent routing algorithms to select optimal edge
              locations based on multiple factors including geographic
              proximity, network latency, server load, and available bandwidth.
              This multi-factor optimization ensures efficient content delivery
              while maintaining cost-effectiveness and high availability.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>Balancing latency, load, bandwidth, and cost dynamically.</li>
              <li>
                Handling real-time traffic for millions of users globally.
              </li>
              <li>Ensuring fast failover to maintain service availability.</li>
            </ul>

            <h5>Algorithm: Dijkstra's Shortest Path Algorithm</h5>
            <p>
              Dijkstra’s algorithm finds the shortest path from the user’s
              location to all AWS CloudFront edge locations in a network graph.
              Each connection has a weight representing latency, load, and
              congestion. Starting from the user, the algorithm repeatedly picks
              the closest unvisited node, updates distances to neighbors if
              shorter paths are found, and continues until the best edge
              location is identified. This ensures content is delivered via the
              fastest and least congested route.
            </p>

            <figure style="text-align: center">
              <img
                src="gif/dijkstar.gif"
                alt="Dijkstra's Algorithm Visualization"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 35: Dijkstra's Shortest Path Algorithm Visualization[24]
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              A user in Mumbai requests a video. CloudFront considers multiple
              edges with different latency and load. Using Dijkstra’s algorithm,
              it calculates a combined cost (latency + load) for each edge and
              selects the one with the lowest total. Even if Mumbai edge has
              lowest latency, heavy load may cause the algorithm to choose
              Chennai or Singapore edges instead, ensuring faster delivery
              overall. The selection updates dynamically as conditions change.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li><strong>Time Complexity:</strong> O((V + E) log V)</li>
              <li><strong>Space Complexity:</strong> O(V + E)</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>
                Faster content delivery enhances user experience and engagement.
              </li>
              <li>
                Cost savings through optimized bandwidth and load distribution.
              </li>
              <li>
                Scalable and reliable global content delivery for business
                growth.
              </li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/dijkstr.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Dijkstra's on GitHub
            </a>
          </div>
        </div>
        <div class="use-case">
          <div class="use-case-header" onclick="toggleUseCase(this)">
            <span class="arrow">▸</span>
            4.6 Priority-Based Email Scheduling with AWS Simple Email Service
          </div>
          <div class="use-case-content">
            <p>
              This system addresses the critical challenge of managing email
              communications with varying urgency levels within AWS Simple Email
              Service (SES) environments. By implementing a heap-based priority
              queue architecture, the solution ensures that time-sensitive
              communications such as security alerts, password resets, and
              transaction confirmations receive immediate processing priority,
              even when competing with high-volume marketing campaigns for
              system resources.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>Priority inversion delays critical emails</li>
              <li>High volume slows processing</li>
              <li>SES limits block urgent messages</li>
            </ul>

            <h5>Algorithm: Heap-Based Priority Queue</h5>
            <p>
              Uses a max-heap priority queue to process emails by urgency. Each
              email gets a priority based on type, urgency, and recipients.
              Higher priority emails are sent first to ensure critical messages
              are delivered immediately.
            </p>
            <ul>
              <li>Assign priority based on email details.</li>
              <li>Insert email into heap, maintaining order.</li>
              <li>Remove highest priority email for sending.</li>
              <li>Dynamically adjust priorities if needed.</li>
            </ul>
            <h5>Design Principles:</h5>
            <p>
              Processes emails by priority using an efficient, scalable, fair,
              and simple max-heap design.
            </p>
            <h5>Priority Classification Framework</h5>
            <ul>
              <li>
                <strong>Critical (Priority 1):</strong> Security alerts,
                password resets, account lockouts, payment failures
              </li>
              <li>
                <strong>High (Priority 2):</strong> Order confirmations,
                shipping notifications, invoice alerts
              </li>
              <li>
                <strong>Medium (Priority 3):</strong> Account updates,
                preference changes, general notifications
              </li>
              <li>
                <strong>Low (Priority 4):</strong> Marketing campaigns,
                newsletters, promotional content
              </li>
            </ul>
            <figure style="text-align: center">
              <img
                src="gif/prorityq.gif"
                alt="Priority Queue Animation"
                style="
                  width: 60%;
                  height: auto;
                  display: block;
                  margin: 0 auto;
                  border: none;
                "
              />
              <figcaption
                style="margin-top: 8px; font-style: italic; color: #555"
              >
                Figure 36:Heap-Based Priority Queue Visualization
              </figcaption>
            </figure>

            <h5>Real-Time Usage Example:</h5>
            <p>
              An e-commerce platform sends various emails daily: marketing
              campaigns to thousands, order confirmations, and critical alerts
              like password resets or payment failures. Using the max-heap
              priority queue algorithm, the system assigns high priority to
              urgent emails (e.g., password resets), even if they arrive after
              bulk marketing emails. This ensures customers receive critical
              notifications instantly while marketing emails are queued and sent
              afterward, optimizing delivery speed and customer satisfaction.
            </p>

            <h5>Algorithm Performance Analysis</h5>
            <ul>
              <li>
                <strong>Insertion Complexity:</strong> O(log n) for adding new
                emails to priority queue
              </li>
              <li>
                <strong>Extraction Complexity:</strong> O(log n) for retrieving
                highest-priority email
              </li>
              <li>
                <strong>Space Complexity:</strong> O(n) for heap storage
                requirements
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Faster delivery of critical emails</li>
              <li>Meets SLA and compliance needs</li>
              <li>Optimized cost and resource use</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/priorityQ.c"
              style="
                font-size: 18px;
                color: #0366d6;
                text-decoration: none;
                font-weight: 500;
                transition: color 0.2s ease-in-out,
                  border-bottom 0.2s ease-in-out;
                border-bottom: 1px solid transparent;
              "
              onmouseover="this.style.borderBottom='1px solid #0366d6';"
              onmouseout="this.style.borderBottom='1px solid transparent';"
              target="_blank"
            >
              🔗 View Code on GitHub
            </a>
          </div>
        </div>

        <div class="use-cases-container">
          <h3>5. Amazon Prime Video Use Cases</h3>
          <figure style="text-align: center">
            <img
              src="system-design/primevideo.jpg"
              width="100%"
              height="600px"
              style="border: none"
              alt="Amazon Prime Video System Design"
            />
            <figcaption
              style="margin-top: 8px; font-style: italic; color: #555"
            >
              Figure 37: Amazon Prime Video System Design Architecture
            </figcaption>
          </figure>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.1 Metadata Storage and Retrieval for Video Segments
            </div>
            <div class="use-case-content">
              <p>
                Managing millions of video segments for streaming requires
                efficient storage and retrieval of metadata such as segment ID,
                format, location, and processing status. Fast access to this
                metadata is essential for responsive streaming, real-time
                monitoring, and rapid failure recovery.
              </p>

              <!-- <img
                src="system-design/segment.jpg"
                alt="A* Algorithm Visualization"
                width="600"
                height="400"
              /> -->
              <h5>Challenges:</h5>
              <ul>
                <li>Efficiently managing large-scale metadata.</li>
                <li>Low-latency access for streaming.</li>
                <li>Fast updates for monitoring and recovery.</li>
              </ul>

              <h5>Algorithm : Hash Map</h5>
              <p>
                A hash map is used to store metadata with segment IDs as keys,
                allowing constant average-time (<code>O(1)</code>) operations
                for insertion, lookup, and update. This ensures efficient access
                to metadata in real-time streaming environments.
              </p>
              <figure style="text-align: center">
                <img
                  src="gif/hash map.gif"
                  alt="Hash Map Animation"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 38: Hash Map Visualization[25]
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                When a user streams a video on Amazon Prime Video, the system
                quickly locates the correct video segments by fetching their
                metadata from the hash map using the segment ID as the key. This
                fast access minimizes playback delay and buffering. If a segment
                transcoding fails, its status is updated instantly in the hash
                map, enabling immediate retry or fallback, which enhances
                streaming reliability and user experience.
              </p>
              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  <strong>Insert/Update:</strong> O(1) - Constant time on
                  average for adding or updating metadata.
                </li>
                <li>
                  <strong>Lookup:</strong> O(1) - Instant retrieval of metadata
                  using segment ID as the key.
                </li>
                <li>
                  <strong>Space Complexity:</strong> O(n) - Space grows linearly
                  with the number of video segments.
                </li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>Reduced buffering for smoother playback.</li>
                <li>Better reliability with quick issue handling.</li>
                <li>Optimized costs through efficient resource use.</li>
              </ul>
              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/hashmap.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub
              </a>
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.2 Video Chunking for Scalable Video Streaming
            </div>
            <div class="use-case-content">
              <p>
                When users upload large videos (e.g., movies or events), the
                system splits the video into fixed-size segments (e.g., 5
                seconds each). This makes video processing, storage, and
                streaming more manageable, allowing faster transcoding, parallel
                processing, and adaptive streaming to users with varied
                bandwidth.
              </p>

              <!-- <img
                src="system-design/segment.jpg"
                alt="A* Algorithm Visualization"
                width="600"
                height="400"
              /> -->
              <h5>Challenges:</h5>
              <ul>
                <li>Large video uploads.</li>
                <li>Need real-time processing.</li>
                <li>Users with different bandwidths.</li>
              </ul>

              <h5>Algorithm:Sliding Window / Fixed-Size Chunking</h5>
              <p>
                The video is divided into small, fixed-duration chunks by
                sliding a window of constant size (e.g., 5 seconds) across the
                video timeline. Each resulting segment is independently
                processed, stored, and delivered.
              </p>

              <figure style="text-align: center">
                <img
                  src="gif/sliding.png"
                  alt="Sliding Window Technique Visualization"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                    /* clip-path: inset(0px 0px 200px 0px); */
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 39: Sliding Window Algorithm
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                For a 1-hour movie uploaded by a user, the system extracts
                5-second segments (e.g., segment 1: 0-5 seconds, segment 2: 5-10
                seconds, etc.). Each segment is transcoded and cached
                separately, enabling the CDN to stream the appropriate quality
                chunk based on the viewer’s bandwidth, thus minimizing
                buffering.
              </p>

              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  <strong>Segment Extraction:</strong> O(n) – A linear scan
                  through the video to extract each segment (n = number of
                  segments).
                </li>
                <li>
                  <strong>Parallel Processing:</strong> O(1) per segment – Each
                  chunk can be processed in parallel, allowing scalability.
                </li>
                <li>
                  <strong>Storage Overhead:</strong> O(n) – Each segment is
                  stored independently, requiring linear space relative to the
                  number of segments.
                </li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>Faster playback, less buffering.</li>
                <li>Lower CDN costs and better scalability.</li>
                <li>Better user retention and experience!</li>
              </ul>

              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/sliding.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub
              </a>
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.3 Video Segment Scheduling for Transcoding
            </div>
            <div class="use-case-content">
              <p>
                Once a video is divided into smaller segments, each must be
                transcoded efficiently and in sequence. Scheduling these
                segments properly prevents server overload, avoids processing
                delays, and ensures that the final video is delivered with
                consistent quality across platforms.
              </p>
              <!-- 
              <img
                src="system-design/segment.jpg"
                alt="A* Algorithm Visualization"
                width="600"
                height="400"
              /> -->
              <h5>Challenges:</h5>
              <ul>
                <li>Handling many video segments quickly.</li>
                <li>Maintaining correct processing order.</li>
                <li>Managing server overloads and failures.</li>
              </ul>

              <h5>FIFO Queue</h5>
              <p>
                A First-In-First-Out (FIFO) queue is used to schedule video
                segment processing. Segments are added to the queue in the order
                they are created and transcoded sequentially. This ensures order
                integrity and simplifies recovery in case of failure by
                re-inserting segments back into the queue.
              </p>

              <figure style="text-align: center">
                <img
                  src="gif/fifo.gif"
                  alt="FIFO Queue Animation"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 40: FIFO Queue Visualization[26]
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                When a user uploads a video, the splitter generates multiple
                segments that enter the processing queue. Each segment waits its
                turn and is transcoded in order. If transcoding for a segment
                fails due to server issues, that segment can be reinserted into
                the queue for retry. This orderly processing ensures the final
                video is ready for streaming without missing or out-of-order
                parts.
              </p>
              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  <strong>Enqueue (Add):</strong> O(1) – Adds a segment to the
                  end of the queue instantly.
                </li>
                <li>
                  <strong>Dequeue (Process):</strong> O(1) – Fetches the next
                  segment in constant time.
                </li>
                <li>
                  <strong>Space Complexity:</strong> O(n) – Space grows linearly
                  with the number of queued segments.
                </li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>Smoother video playback.</li>
                <li>Lower transcoding costs.</li>
                <li>Faster video delivery and happier users.</li>
              </ul>
              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/fifo.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub
              </a>
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.4 Max-Flow Optimization for Prime Video Delivery
            </div>
            <div class="use-case-content">
              <p>
                Applying network flow optimization techniques to enhance the
                delivery of video content across Prime Video's infrastructure.
                The objective is to ensure efficient content distribution by
                minimizing latency, reducing bottlenecks, and optimizing the
                overall network performance, particularly under heavy load
                conditions.
              </p>
              <h5>Challenges:</h5>
              <ul>
                <li>Adapting to traffic changes</li>
                <li>Balancing server load</li>
                <li>Avoiding congestion</li>
                <li>Maximizing streaming quality</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="system-design/ford.jpg"
                  alt="Ford Algorithm Visualization"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 41:Workflow of Max-Flow Optimization Algorithm for
                  Efficient Prime Video Content Delivery
                </figcaption>
              </figure>

              <h5>Algorithm Description: Ford-Fulkerson (Max-Flow)</h5>
              <p>
                Ford-Fulkerson finds the maximum flow in a network by repeatedly
                identifying augmenting paths from source to sink and pushing
                flow through them. It uses a residual graph to track remaining
                capacities and updates flows until no more paths can be found.
              </p>

              <h5>Design Principles:</h5>
              <ul>
                <li>Residual graph tracks available capacity.</li>
                <li>Augmenting paths found via DFS or BFS.</li>
                <li>Flow updated along valid paths.</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="gif/ford.gif"
                  alt="Ford-Fulkerson Algorithm Animation"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 42: Visualization of Ford-Fulkerson Algorithm[27]
                </figcaption>
              </figure>

              <h5>Real-Time Usage:</h5>

              <p>
                During a major Prime Video event, Ford-Fulkerson quickly routes
                video streams from data centers to edge servers by finding
                max-flow paths. When some routes get congested, it reroutes
                traffic through alternate paths, minimizing buffering and
                ensuring smooth streaming for millions of users.
              </p>

              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  Time complexity: O(E × f), where E is the number of edges and
                  f is the maximum flow
                </li>
                <li>
                  Space complexity: O(V + E) for storing the residual graph,
                  where V is vertices and E is edges
                </li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>Less buffering and latency</li>
                <li>Efficient resource use</li>
                <li>Scalable for peak traffic</li>
                <li>Reliable delivery during failures</li>
              </ul>

              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/ford_fulkerson.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Ford-Fulkerson Code Here</a
              >
              <br />
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.5 Optimized Content Delivery and Edge Caching in Amazon Prime
              Video
            </div>
            <div class="use-case-content">
              <p>
                Amazon Prime Video serves millions of users globally with
                high-quality streaming content. To provide seamless and
                low-latency video playback, Prime Video uses a global Content
                Delivery Network (CDN) that caches video segments on
                geographically distributed edge servers.
              </p>
              <p>
                Since each edge server has limited storage capacity, it cannot
                cache every video segment. Efficient cache management is
                critical to ensure popular and frequently requested video
                segments remain close to users, reducing buffering and improving
                playback quality.
              </p>
              <!-- <img
                src="system-design/segment.jpg"
                alt="A* Algorithm Visualization"
                width="600"
                height="400"
              /> -->
              <h5>Challenges:</h5>
              <ul>
                <li>Limited storage capacity on edge servers</li>
                <li>High volume of diverse content requests</li>
                <li>Need for real-time low-latency streaming</li>
              </ul>

              <h5>Algorithm: LRU Cache</h5>
              <ul>
                <li>
                  Maintains cache entries in a doubly linked list reflecting
                  usage order.
                </li>
                <li>Uses a hash map for quick lookup of video segments.</li>
                <li>
                  On cache hits, moves accessed segment to the front (most
                  recently used).
                </li>
                <li>
                  On cache misses, adds the new segment and evicts the tail
                  (least recently used) if the cache is full.
                </li>
              </ul>

              <figure style="text-align: center">
                <img
                  src="gif/lru1.gif"
                  alt="LRU Cache Animation 1"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
              </figure>

              <figure style="text-align: center">
                <img
                  src="gif/lru2.gif"
                  alt="LRU Cache Animation 2"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
              </figure>

              <figure style="text-align: center">
                <img
                  src="gif/lru3.gif"
                  alt="LRU Cache Animation 3"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 44: LRU Cache Algorithm Visualization[10]
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                When a user in India streams a new episode of “The Boys,” the
                local CDN edge server caches the streamed segments. As more
                users request segments, the cache fills. The LRU algorithm
                evicts older, less accessed segments (e.g., last month’s less
                popular shows) to make room for currently trending video
                segments, ensuring smooth streaming with reduced buffering.
              </p>

              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  <strong>Get:</strong> O(1) — Constant time lookup using hash
                  map
                </li>
                <li>
                  <strong>Put:</strong> O(1) — Insert at the head of the doubly
                  linked list
                </li>
                <li>
                  <strong>Eviction:</strong> O(1) — Remove the tail node (least
                  recently used)
                </li>
                <li>
                  <strong>Space:</strong> O(n) — Where n is the number of cache
                  entries
                </li>
              </ul>
              <h5>Market Benefits:</h5>
              <ul>
                <li>Reduced latency for faster video start</li>
                <li>Optimized bandwidth by serving cached content locally</li>
                <li>Improved user experience and retention</li>
              </ul>
              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/lru.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub
              </a>
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.6 Prime Video — Fast Title/Description Search using KMP
            </div>
            <div class="use-case-content">
              <p>
                When a user searches for a show or movie (e.g., types "time
                traveler"), Prime Video must quickly scan through millions of
                titles, descriptions, and subtitles to find matches.
              </p>
              <h5>Challenges:</h5>
              <ul>
                <li>Fast, low-latency search over millions of titles</li>
                <li>Efficient memory use for large-scale exact matching</li>
                <li>Supports multilingual exact search</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="system-design/kmp.jpg"
                  alt="KMP Algorithm Visualization"
                  style="
                    width: 50%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 45:Workflow of Prime Video’s Efficient Title and
                  Description Search Using the KMP Algorithm
                </figcaption>
              </figure>

              <h5>Algorithm: Knuth-Morris-Pratt (KMP)</h5>
              <p>
                KMP searches for a pattern by preprocessing it into an LPS
                table, enabling fast, linear-time matching without backtracking.
              </p>

              <h5>Design Principles:</h5>
              <ul>
                <li>
                  Preprocess pattern with LPS table for efficient matching.
                </li>
                <li>Skip redundant comparisons to speed up search.</li>
                <li>Linear time complexity O(N + M) for scalability.</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="gif/kmp-algorithm-approach.gif"
                  alt="KMP Algorithm Approach Animation"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 46: Knuth-Morris-Pratt Algorithm visualization[28]
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                When a user searches for “time traveler” on Prime Video, KMP
                scans titles, descriptions, and subtitles in linear time,
                avoiding repeated comparisons.
              </p>
              <p>
                For example, it quickly matches titles like
                <em>“The Time Traveler’s Wife”</em> without rescanning text,
                enabling instant, accurate, and multilingual search suggestions.
              </p>

              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  Time complexity: O(N + M), where N is the text length and M is
                  the pattern length
                </li>
                <li>
                  Space complexity: O(M) for the LPS (Longest Prefix Suffix)
                  table
                </li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>Quick search improves user experience</li>
                <li>Boosts content discovery and engagement</li>
                <li>Scalable and cost-effective solution</li>
              </ul>
              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/kmp.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub</a
              >
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.7 Tracking Viewing Progress in Prime Video
            </div>
            <div class="use-case-content">
              <p>
                Prime Video tracks each user’s viewing progress in real time to
                enable features like “Continue Watching” and personalized
                recommendations. It keeps a history of interactions to:
              </p>
              <ul>
                <li>Resume content accurately across devices</li>
                <li>Analyze viewing patterns and binge behavior</li>
                <li>Optionally revert to previous watch states</li>
              </ul>
              <p>
                This ensures a seamless and personalized streaming experience.
              </p>

              <h5>Challenges:</h5>
              <ul>
                <li>
                  Efficiently track viewing progress with minimal data
                  duplication
                </li>
                <li>
                  Fast retrieval of current and past viewing states (versioning)
                </li>
                <li>
                  Support cross-device sync and rollback to previous states
                </li>
                <li>Minimize storage by sharing unchanged data</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="system-design/p_seg_tree.jpg"
                  alt="Persistent Segment Tree Visualization"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 47:Workflow of Viewing Progress Tracking in Prime Video
                </figcaption>
              </figure>

              <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

              <h5>Algorithm: Persistent Segment Tree</h5>

              <p>
                A Persistent Segment Tree keeps all past versions after updates
                by creating new versions instead of overwriting data. This
                enables efficient queries on any previous state, useful for
                tracking changes or undoing updates.
              </p>
              <h5>Design Principles:</h5>
              <ul>
                <li>
                  Partial copying saves memory by duplicating only changed
                  nodes.
                </li>
                <li>
                  Immutable versions keep historical states safe for queries.
                </li>
                <li>Updates and queries run efficiently in O(log n) time.</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="gif/persistant segment tree.png"
                  alt="Persistent Segment Tree Animation"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 48:Persistent Segment Tree Algorithm[29]
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                When a user watches an episode on Prime Video, a new version of
                their progress is saved using a persistent segment tree. Only
                the changed part (e.g., progress from 10 to 15 mins) is stored,
                keeping previous states intact.
              </p>
              <p>
                For example, if the user pauses at 15 minutes on one device and
                resumes later on another, the system instantly retrieves the
                latest version. If needed, it can also roll back to a previous
                timestamp.
              </p>

              <!-- Analysis Section -->
              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>Update and Query time: O(log n) each</li>
                <li>
                  Space complexity: O(n log n) for persistent segment tree
                  versions
                </li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>
                  Seamless user experience with accurate progress tracking
                </li>
                <li>Improved retention via personalized recommendations</li>
                <li>Reliable and scalable data management across devices</li>
              </ul>

              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/psegment_tree.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub
              </a>
            </div>
          </div>

          <div class="use-case">
            <div class="use-case-header" onclick="toggleUseCase(this)">
              <span class="arrow">▸</span>
              5.8 Amazon Prime Video: Range Query Optimization
            </div>
            <div class="use-case-content">
              <p>
                Amazon Prime Video processes massive amounts of data daily,
                including views, ratings, and user interactions. Frequent
                range-based queries, such as filtering by date, genre, or
                language, make real-time analytics and insights challenging with
                traditional data processing methods.
              </p>
              <h5>Challenges:</h5>
              <ul>
                <li>Handling frequent range-based queries on large datasets</li>
                <li>Real-time updates with new views and ratings</li>
                <li>
                  Multidimensional filtering (e.g., time, genre, language)
                </li>
                <li>Maintaining fast query response times for dashboards</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="system-design/segment.jpg"
                  alt="Segment Tree Visualization"
                  style="
                    width: 50%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 49: Workflow of Range Query Optimization in Amazon
                  Prime Video
                </figcaption>
              </figure>

              <h5>Algorithm: Segment Tree</h5>
              <p>
                Segment Tree is a tree that efficiently answers range queries on
                an array by storing pre-calculated results for different
                segments.
              </p>
              <h5>Design Principle</h5>
              <ul>
                <li>Divide and conquer by splitting into smaller segments.</li>
                <li>Nodes store combined data for fast queries.</li>
                <li>Updates affect only relevant nodes for efficiency.</li>
              </ul>
              <figure style="text-align: center">
                <img
                  src="gif/segment.gif"
                  alt="Segment Tree Animation"
                  style="
                    width: 60%;
                    height: auto;
                    display: block;
                    margin: 0 auto;
                    border: none;
                  "
                />
                <figcaption
                  style="margin-top: 8px; font-style: italic; color: #555"
                >
                  Figure 50: Segment Tree Visualization[30]
                </figcaption>
              </figure>

              <h5>Real-Time Usage</h5>
              <p>
                Amazon uses segment trees to power dashboards showing real-time
                stats. For example, to compute:
                <strong
                  >"Total views for Hindi Thriller movies in the last 30
                  days"</strong
                >, a segment tree is used to quickly sum views within the
                required date range and genre.
              </p>
              <p>
                When a user watches a new movie or gives a rating, the tree
                updates only affected segments, ensuring instant and efficient
                analytics across large datasets.
              </p>

              <h5>Algorithm Performance Analysis</h5>
              <ul>
                <li>
                  Query: O(log N) for fast range queries (e.g., views in last 7
                  days)
                </li>
                <li>
                  Update: O(log N) to reflect new ratings or views in real time
                </li>
                <li>Build: O(N) time to construct the tree initially</li>
                <li>Space: O(4N) to store segment and child nodes</li>
              </ul>

              <h5>Market Benefits:</h5>
              <ul>
                <li>
                  Faster, real-time analytics for improved decision-making
                </li>
                <li>Reduced backend load and operational costs</li>
                <li>Better user experience through timely recommendations</li>
              </ul>
              <a
                href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
                style="
                  font-size: 18px;
                  color: #0366d6;
                  text-decoration: none;
                  font-weight: 500;
                  transition: color 0.2s ease-in-out,
                    border-bottom 0.2s ease-in-out;
                  border-bottom: 1px solid transparent;
                "
                onmouseover="this.style.borderBottom='1px solid #0366d6';"
                onmouseout="this.style.borderBottom='1px solid transparent';"
                target="_blank"
              >
                🔗 View Code on GitHub
              </a>
            </div>
          </div>
        </div>
        <h2>
          <a href="summary.html" class="btn">🔗 View Summary Table</a>
        </h2>
      </section>

      <section id="learnings-section" class="objectives-section">
        <h2>Learnings</h2>
        <div class="objectives-container">
          <div class="objective-item">
            <p>
              <strong>
                Working on this portfolio around Amazon’s different business use
                cases really opened my eyes to how big systems are built,
                scaled, and improved using data structures and algorithms.
                Whether it was video streaming, delivery logistics, or
                recommendation systems, I saw how choosing the right
                algorithms—like tries for searching, segment trees for real-time
                updates, or graphs for routing— can make a huge difference in
                how smoothly everything runs.</strong
              >
            </p>
            <p>
              <strong
                >This project helped me look beyond just writing code. I began
                to understand how these algorithms actually drive innovation at
                a global scale. It also taught me the value of thinking like a
                system designer, modeling solutions based on the problem’s
                domain, and always being ready to learn and adapt. Most
                importantly, I learned how the things we study in DSA and APS
                are used in the real world to solve big, complex
                problems.</strong
              >
            </p>
          </div>
        </div>
      </section>

      <section id="references-section" class="objectives-section">
        <h2>References</h2>
        <ol class="objectives-container">
          <li>
            <a
              href="https://medium.com/nerd-for-tech/designing-a-video-on-demand-system-like-netflix-amazon-prime-etc-df4a61a9424f"
              target="_blank"
              rel="noopener noreferrer"
            >
              Designing a VOD System – Wickramanayake
            </a>
          </li>
          <li>
            <a
              href="https://medium.com/@ayush_mittal/system-design-for-logistics-management-system-80b876e29bbb"
              target="_blank"
              rel="noopener noreferrer"
            >
              Logistics System Design – Mittal
            </a>
          </li>
          <li>
            <a
              href="https://www.tryexponent.com/questions/4802/design-amazon-prime-video"
              target="_blank"
              rel="noopener noreferrer"
            >
              Design Amazon Prime Video – Exponent
            </a>
          </li>
          <li>
            <a
              href="https://aws.amazon.com/blogs/architecture/lets-architect-designing-well-architected-systems/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Well-Architected Systems – AWS Blog
            </a>
          </li>
          <li>
            <a
              href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Union Find – HackerEarth
            </a>
          </li>
          <li>
            <a
              href="https://medium.com/@kethan.pothula/amazon-system-design-and-architecture-d787a6572f35"
              target="_blank"
              rel="noopener noreferrer"
            >
              Amazon Architecture – Pothula
            </a>
          </li>
          <li>
            <a
              href="https://tekton.cloud/architecture-diagram-aws/"
              target="_blank"
              rel="noopener noreferrer"
            >
              AWS Architecture Diagram – Tekton
            </a>
          </li>
          <li>
            <a
              href="https://k21academy.com/amazon-web-services/architecture/"
              target="_blank"
              rel="noopener noreferrer"
            >
              AWS Architecture – K21Academy
            </a>
          </li>
          <li>
            <a
              href="https://blog.algomaster.io/p/load-balancing-algorithms-explained-with-code"
              target="_blank"
              rel="noopener noreferrer"
            >
              Load Balancing Algorithms – Algomaster
            </a>
          </li>
          <li>
            <a
              href="https://medium.com/@getrohith.sathya/lru-cache-implementation-using-java-22dd5c218502"
              target="_blank"
              rel="noopener noreferrer"
            >
              LRU Cache in Java – Sathya
            </a>
          </li>
          <li>
            <a
              href="https://gabrielcastro1028.medium.com/trie-data-structure-4a8becc97809"
              target="_blank"
              rel="noopener noreferrer"
            >
              Trie Data Structure – Gabriel Castro
            </a>
          </li>
          <li>
            <a
              href="https://medium.com/@for.wlb.biz/introduction-to-binary-tree-b-tree-b-tree-1ffd62279963"
              target="_blank"
              rel="noopener noreferrer"
            >
              Introduction to Binary Tree, B-Tree – for.wlb.biz
            </a>
          </li>
          <li>
            <a
              href="https://skerritt.blog/timsort/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Timsort Explained – Skerritt Blog
            </a>
          </li>
          <li>
            <a
              href="https://stollee.org/2011/09/k-d-tree-nearest-neighbor-search.html"
              target="_blank"
              rel="noopener noreferrer"
            >
              KD-Tree Nearest Neighbor Search – Stollee
            </a>
          </li>
          <li>
            <a
              href="https://en.wikipedia.org/wiki/PageRank"
              target="_blank"
              rel="noopener noreferrer"
            >
              PageRank – Wikipedia
            </a>
          </li>
          <li>
            <a
              href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure"
              target="_blank"
              rel="noopener noreferrer"
            >
              Disjoint-set Data Structure – Wikipedia
            </a>
          </li>
          <li>
            <a
              href="https://www.hackerearth.com/practice/notes/mos-algorithm/"
              target="_blank"
              rel="noopener noreferrer"
            >
              MO's Algorithm – HackerEarth
            </a>
          </li>
          <li>
            <a
              href="https://astikanand.github.io/techblogs/dynamic-programming-patterns/0-1-knapsack-pattern"
              target="_blank"
              rel="noopener noreferrer"
            >
              0-1 Knapsack Pattern – Astikanand's Tech Blogs
            </a>
          </li>
          <li>
            <a
              href="https://medium.com/@askurkure123/krushkals-algorithm-477d89e1e9e2"
              target="_blank"
              rel="noopener noreferrer"
            >
              Kruskal's Algorithm – Askurkure
            </a>
          </li>
          <li>
            <a
              href="https://inteligenciafutura.mx/english-version-blog/games-routes-and-circuits-problem-solving-with-artificial-intelligence"
              target="_blank"
              rel="noopener noreferrer"
            >
              Games, Routes and Circuits: Problem Solving with AI – Inteligencia
              Futura
            </a>
          </li>

          <li>
            <a
              href="https://python.plainenglish.io/exploring-the-foundations-and-applications-of-the-stable-match-problem-from-theory-to-practice-3f43d778a8bf"
              target="_blank"
              rel="noopener noreferrer"
            >
              Exploring the Foundations and Applications of the Stable Match
              Problem – Plain English Python
            </a>
          </li>
          <li>
            <a
              href="https://en.wikipedia.org/wiki/A*_search_algorithm"
              target="_blank"
              rel="noopener noreferrer"
            >
              A* Search Algorithm – Wikipedia
            </a>
          </li>
          <li>
            <a
              href="https://www.hackerearth.com/blog/competitive-programming-anudeep-nekkanti"
              target="_blank"
              rel="noopener noreferrer"
            >
              Square Root Decomposition Algorithm with Anudeep Nekkanti –
              HackerEarth
            </a>
          </li>
          <li>
            <a
              href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
              target="_blank"
              rel="noopener noreferrer"
            >
              Dijkstra's Algorithm – Wikipedia
            </a>
          </li>
          <li>
            <a
              href="https://brilliant.org/wiki/hash-tables/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Hash Tables – Brilliant
            </a>
          </li>
          <li>
            <a
              href="https://www.scaler.com/topics/java/stack-and-queue-in-java/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Stack and Queue in Java – Scaler
            </a>
          </li>
          <li>
            <a
              href="https://commons.wikimedia.org/wiki/File:FordFulkersonDemo.gif"
              target="_blank"
              rel="noopener noreferrer"
            >
              Ford-Fulkerson Algorithm Demo – Wikimedia Commons
            </a>
          </li>
          <li>
            <a
              href="https://www.scaler.com/topics/data-structures/kmp-algorithm/"
              target="_blank"
              rel="noopener noreferrer"
            >
              KMP Algorithm – Scaler
            </a>
          </li>
          <li>
            <a
              href="https://www.geeksforgeeks.org/persistent-segment-tree-set-1-introduction/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Persistent Segment Tree – GeeksforGeeks
            </a>
          </li>
          <li>
            <a
              href="https://www.scaler.com/topics/data-structures/segment-trees-in-data-structure/"
              target="_blank"
              rel="noopener noreferrer"
            >
              Segment Trees in Data Structure – Scaler
            </a>
          </li>
        </ol>
      </section>
    </main>

    <footer>
      <p>&copy; 2025 Anjali Savalkar. All rights reserved.</p>
    </footer>
    <script>
      function toggleUseCase(header) {
        const content = header.nextElementSibling;
        const arrow = header.querySelector(".arrow");
        const isVisible = content.style.display === "block";
        content.style.display = isVisible ? "none" : "block";
        arrow.textContent = isVisible ? "▸" : "▾";
      }
    </script>
  </body>
</html>
