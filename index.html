<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anjali Savalkar - Algorithmic Problem Solving Portfolio</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- NAVBAR -->
    <nav>
      <div class="left">
        <a href="/">Anjali Savalkar</a>
      </div>

      <div class="right">
        <a
          href="https://github.com/AnjaliSavalkardummy"
          target="_blank"
          rel="noopener noreferrer"
        >
          <i class="fa-brands fa-github"></i>
          <span>Github</span>
        </a>

        <a
          href="https://www.linkedin.com/in/anjali-savalkardummy-39998925a"
          target="_blank"
          rel="noopener noreferrer"
        >
          <i class="fa-brands fa-linkedin"></i>
          <span>LinkedIn</span>
        </a>

        <a href="mailto:savalkaranjali6@gmail.com">
          <i class="fa-solid fa-envelope"></i>
          <span>Email</span>
        </a>
      </div>
    </nav>

    <main>
      <!-- SECTION 1: Hero -->
      <section class="hero-section">
        <div class="content">
          <h1>
            Algorithmic Problem Solving<br />
            <span class="highlight">Portfolio</span>
          </h1>

          <div class="links">
            <a href="#academic-details">
              <i class="fa-solid fa-graduation-cap"></i>
              <span>Academic Details</span>
            </a>
            <a href="#domain">
              <i class="fa-solid fa-code"></i>
              <span>Domain</span>
            </a>
            <a href="#business-case-study">
              <i class="fa-solid fa-lightbulb"></i>
              <span>Business Use Cases</span>
            </a>
            <a href="#skills">
              <i class="fa-solid fa-laptop-code"></i>
              <span>Skills</span>
            </a>
          </div>
        </div>

        <div class="custom-shape-divider-bottom-hero">
          <svg viewBox="0 0 1200 120" preserveAspectRatio="none">
            <path
              d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V0Z"
              opacity="1"
              fill="#ffffff"
            ></path>
          </svg>
        </div>
      </section>

      <!-- SECTION 2: Academic Details -->
      <section id="academic-details" class="academic-details-section">
        <h2>🎓 Academic Details</h2>
        <dl>
          <dt>Name</dt>
          <dd>Anjali Savalkar</dd>

          <dt>SRN (Student Roll Number)</dt>
          <dd>01FE22BCS196</dd>

          <dt>Course Name</dt>
          <dd>Algorithmic Problem Solving</dd>

          <dt>Course Code</dt>
          <dd>24ECSE309</dd>

          <dt>Course Instructor</dt>
          <dd>Prakash Hegade</dd>

          <dt>University</dt>
          <dd>KLE Technological University</dd>

          <dt>Portfolio Topic/Domain</dt>
          <dd>
            <img
              src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg"
              alt="Amazon Logo"
              class="amazon-logo"
            />
          </dd>
        </dl>
      </section>

      <section id="about-me" class="about-me-section">
        <h2>About Me</h2>
        <div class="about-container">
          <p>
            I'm Anjali Savalkar, a passionate web developer currently pursuing
            my degree in Computer Science at KLE Technological University. I
            enjoy transforming ideas into interactive and visually appealing
            websites. My interests lie in full-stack development,
            problem-solving, and applying Data Structures and Algorithms o solve
            real-time use cases and optimize technological solutions.
          </p>
          <p class="fun-fact">
            <strong>Fun Fact:</strong> I love debugging code almost as much as
            building it—it’s like solving a mystery with logic!
          </p>
        </div>
      </section>

      <!-- SECTION 3: Skills -->
      <section id="skills" class="skills-section">
        <h2>💻 Skills</h2>

        <div class="skills-container">
          <!-- Languages -->
          <div class="skill-category">
            <h3>Languages</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/1/18/C_Programming_Language.svg"
                  alt="C"
                />
                <p>C</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/1/18/ISO_C%2B%2B_Logo.svg"
                  alt="C++"
                />
                <p>C++</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/6/6a/JavaScript-logo.png"
                  alt="JavaScript"
                />
                <p>JavaScript</p>
              </div>
            </div>
          </div>

          <!-- Web Development -->
          <div class="skill-category">
            <h3>Web Development</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/6/61/HTML5_logo_and_wordmark.svg"
                  alt="HTML"
                />
                <p>HTML</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/d/d5/CSS3_logo_and_wordmark.svg"
                  alt="CSS"
                />
                <p>CSS</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg"
                  alt="React"
                />
                <p>React</p>
              </div>
              <div class="skill-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/d/d9/Node.js_logo.svg"
                  alt="Node.js"
                />
                <p>Node.js</p>
              </div>
            </div>
          </div>

          <!-- Databases -->
          <div class="skill-category">
            <h3>Databases</h3>
            <div class="skills-list">
              <div class="skill-item">
                <img src="images/mongo.png" alt="MongoDB" />
                <p>MongoDB</p>
              </div>
              <div class="skill-item">
                <img src="images/mysql.png" alt="MySQL" />
                <p>MySQL</p>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="projects" class="projects-section">
        <h2>Projects</h2>
        <div class="projects-container">
          <div class="project-card">
            <h3>Netflix Clone</h3>
            <p>
              A replica of the popular Netflix homepage, featuring a clean,
              modern interface with responsive design. This project demonstrates
              my ability to work with HTML, CSS, JavaScript, and React to create
              a user-friendly streaming platform experience.
            </p>
            <ul>
              <li>Front-End: React, CSS, JavaScript</li>
              <li>Features: Responsive Design, Carousel, Movie Grid</li>
            </ul>
            <p>
              The project includes a fully responsive homepage with a clean
              layout and smooth transitions between elements.
            </p>
          </div>

          <div class="project-card">
            <h3>Few-Shot Brain Tumor Segmentation</h3>
            <p>
              This project focuses on leveraging few-shot learning techniques
              for accurate segmentation of brain tumors. The goal was to use
              minimal labeled data while achieving high performance in detecting
              tumor regions in MRI scans.
            </p>
            <ul>
              <li>
                Approach: Few-Shot Learning, Transfer Learning, Semantic
                Segmentation
              </li>
              <li>Dataset: BraTS 2021</li>
              <li>Model: Custom CNN + Pre-trained Models (Unet)</li>
              <li>
                Evaluation: Mean Intersection over Union (mIoU), Dice
                Coefficient
              </li>
              <li>Tools: PyTorch, NumPy, OpenCV</li>
            </ul>
          </div>

          <div class="project-card">
            <h3>Shopper Commerce Website</h3>
            <p>
              A fully functional e-commerce website built with modern web
              technologies, offering a seamless shopping experience. Users can
              browse products, add to cart, and securely check out.
            </p>
            <ul>
              <li>Stack: HTML, CSS, JavaScript, React, Node.js, MongoDB</li>
              <li>
                Features: Product listing, cart system, order tracking, admin
                dashboard
              </li>
              <li>
                Authentication: User login, registration, and JWT-based session
                management
              </li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/stone-paper-scissors"
              target="_blank"
            >
              View on GitHub
            </a>
          </div>
        </div>
      </section>

      <!-- SECTION 4: Domain -->
      <section id="domain" class="domain-section">
        <h2>Domain - Amazon</h2>

        <div class="domain-container">
          <div class="domain-details">
            <div class="statement">
              <p>
                Amazon is a global technology company recognized for its
                innovation and leadership in multiple domains including
                e-commerce, cloud computing (AWS), digital streaming, and
                artificial intelligence.
              </p>
              <p>
                Amazon's mission is to be "Earth's most customer-centric
                company," constantly striving to improve customer experience
                through technology and efficiency.
              </p>
            </div>

            <div class="services">
              <h3>Amazon Services:</h3>
              <div class="service-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/9/93/Amazon_Web_Services_Logo.svg"
                  alt="AWS Logo"
                />
                <div>
                  <h4>Amazon Web Services (AWS)</h4>
                  <p>
                    Amazon Web Services (AWS) is the world’s leading cloud
                    computing platform, offering scalable solutions for compute
                    power, storage, AI/ML, security, and more. It powers a
                    significant portion of the internet and holds approximately
                    31% of the global cloud market share.
                  </p>
                </div>
              </div>

              <div class="service-item">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/d/de/Amazon_icon.png"
                  alt="Amazon E-commerce Icon"
                />
                <div>
                  <h4>E-commerce Platform</h4>
                  <p>
                    Amazon is the world’s largest online marketplace, serving
                    hundreds of millions of users globally. It offers a vast
                    selection of products on Amazon.com, enhanced by
                    personalized recommendations, fast shipping, and customer
                    reviews.
                  </p>
                </div>
              </div>

              <div class="service-item">
                <img src="images/prime.png" alt="Prime Video Icon" />
                <div>
                  <h4>Prime Video & Digital Streaming</h4>
                  <p>
                    Amazon Prime offers fast shipping, video streaming, and
                    music, serving millions with movies, shows, and original
                    content.
                  </p>
                </div>
              </div>
              <div class="service-item">
                <img src="images/alexa.png" alt="Prime Video Icon" />
                <div>
                  <h4>Alexa</h4>
                  <p>
                    Amazon’s voice-powered assistant for smart home and IoT.
                  </p>
                </div>
              </div>

              <div class="service-item">
                <img src="images/logistic.png" alt="Prime Video Icon" />
                <div>
                  <h4>Amazon Logistics</h4>
                  <p>
                    Advanced delivery and fulfillment network, including drone
                    and robotic delivery innovations.
                  </p>
                </div>
              </div>
            </div>
            <div class="statement">
              <p>
                <strong>Amazon’s ecosystem</strong> is a complex digital
                infrastructure that thrives on optimization and intelligent
                automation. This portfolio demonstrates how theoretical
                knowledge of algorithms can be harnessed to improve key
                functionalities across Amazon’s services.
              </p>

              <p>
                Each case study includes a real-world challenge, a DSA-based
                solution, and a performance analysis to quantify the impact.
              </p>

              <p>
                <em
                  >Join me as we explore the intersection of theory and
                  application in one of the world’s most advanced digital
                  ecosystems — Amazon.</em
                >
              </p>
            </div>
          </div>
        </div>
      </section>
      <section id="stuff-section" class="stuff-section">
        <div class="statement">
          <p>
            <strong>Amazon’s ecosystem</strong> is a complex digital
            infrastructure that thrives on optimization and intelligent
            automation. This portfolio demonstrates how theoretical knowledge of
            algorithms can be harnessed to improve key functionalities across
            Amazon’s services.
          </p>

          <p>
            Each case study includes a real-world challenge, a DSA-based
            solution, and a performance analysis to quantify the impact.
          </p>

          <p>
            <em
              >Join me as we explore the intersection of theory and application
              in one of the world’s most advanced digital ecosystems —
              Amazon.</em
            >
          </p>
        </div>
      </section>
      <section id="objectives-section" class="objectives-section">
        <h2>Objectives</h2>
        <div class="objectives-container">
          <div class="objective-item">
            <p>
              <strong>To apply advanced algorithms and data structures</strong>
              to enhance the speed, scalability, and operational efficiency of
              Amazon's diverse services including e-commerce, logistics, cloud
              computing, and digital media.
            </p>
          </div>
          <div class="objective-item">
            <p>
              <strong
                >To demonstrate the practical application of concepts from Data
                Structures and Algorithms (DSA) and Algorithmic Problem Solving
                (APS)</strong
              >
              by addressing real-world engineering challenges in Amazon's
              large-scale systems.
            </p>
          </div>
          <div class="objective-item">
            <p>
              <strong
                >To propose algorithmic solutions that optimize customer
                experience, improve supply chain and fulfillment accuracy,
                enhance search and recommendation systems, and maximize business
                outcomes</strong
              >
              across Amazon's technological ecosystem.
            </p>
          </div>
        </div>
      </section>
      <!-- SECTION 4: Skills -->

      <!-- SECTION 5: Business Use Cases -->
      <section id="business-case-study" class="business-case-study-section">
        <h2>💡 Business Use Cases</h2>
        <div class="use-cases-container">
          <div class="use-case">
            <h4>1. Amazon Prime Video: Range Query Optimization</h4>
            <p>
              Amazon Prime Video processes massive amounts of data daily,
              including views, ratings, and user interactions. Frequent
              range-based queries, such as filtering by date, genre, or
              language, make real-time analytics and insights challenging with
              traditional data processing methods.
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>
                Huge data volume from millions of views and ratings daily.
              </li>
              <li>
                Frequent range-based queries (e.g., by date, genre, rating).
              </li>
              <li>Need for real-time updates as new views/ratings come in.</li>
              <li>Multidimensional filters (e.g., time + genre + language).</li>
              <li>
                High query frequency from dashboards and recommendation systems.
              </li>
              <li>
                Scalability issues as the user base and content library grow.
              </li>
              <li>
                Slow query response using traditional methods like full scans or
                SQL group-bys.
              </li>
              <li>
                Inconsistent or delayed analytics in real-time dashboards.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                Faster analytics improves user experience with live stats and
                recommendations.
              </li>
              <li>
                Reduces backend load, cutting down infrastructure and
                operational costs.
              </li>
              <li>
                Enables smarter decision-making, as trends can be tracked and
                acted upon instantly.
              </li>
              <li>
                Improves content discovery, boosting engagement and viewership.
              </li>
              <li>
                Supports real-time personalization, making recommendations more
                relevant.
              </li>
              <li>
                Gives Amazon a competitive edge by making data-driven decisions
                in real time.
              </li>
            </ul>

            <h5>Algorithm: Segment Tree</h5>
            <p>
              <!-- <li>
                <strong>Divide and Conquer:</strong> Segment Tree divides data
                into segments, each node represents a range, and operations
                (queries and updates) are done on these segments.
              </li>
              <li>
                <strong>Efficient Query/Update:</strong> Supports O(log N) time
                complexity for both range queries and updates, enabling fast
                responses and real-time analytics.
              </li>
              <li>
                <strong>Space Complexity:</strong> Uses O(N) space, with N being
                the number of elements, making it space-efficient for large
                datasets.
              </li>
              <li>
                <strong>Lazy Propagation:</strong> Optimizes range updates by
                deferring updates to improve performance in specific scenarios
                (e.g., multiple range updates).
              </li> -->
              Segment Tree is a tree that efficiently answers range queries on
              an array by storing pre-calculated results for different
              segments.<br />

              <strong>Design Principle:</strong> Use divide and conquer to build
              a hierarchical summary where each node holds an aggregate value
              for its range, enabling fast range queries by combining these
              pre-computed results.
            </p>

            <h5>Usage</h5>
            <p>
              <strong>Scenario:</strong> Amazon wants to show a live dashboard
              to Prime Video managers with the following insights:
            </p>

            <ul>
              <li>Total views in the last 7 days</li>
              <li>Average rating for “Thriller” movies in the last 30 days</li>
              <li>
                Number of “Hindi” language views between January and March
              </li>
              <li>Real-time update when a user rates a show</li>
            </ul>
            <h5>Analysis</h5>
            <ul>
              <li>
                <strong>Query:</strong> O(log N) for fast range queries (e.g.,
                views in last 7 days)
              </li>
              <li>
                <strong>Update:</strong> O(log N) to reflect new ratings or
                views in real time
              </li>
              <li>
                <strong>Build:</strong> O(N) time to construct the tree
                initially
              </li>
              <li>
                <strong>Space:</strong> O(4N) to store segment and child nodes
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <h3>Segment Tree Visualization</h3>
            <iframe
              src="gif/segment.gif"
              width="100%"
              height="600px"
              style="border: none"
            ></iframe>
          </div>
          <div class="use-case">
            <h4>2. Delivery Route Planning</h4>
            <p>
              Amazon is developing advanced drone and robotics technologies to
              revolutionize last-mile delivery. Prime Air focuses on rapid
              package delivery via drones, while Scout uses autonomous ground
              robots.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                Traffic/Conditions: Dynamic roadblocks, accidents, and
                construction.
              </li>
              <li>
                Dynamic Constraints: Last-minute stop changes, vehicle limits
                (battery, capacity).
              </li>
              <li>
                Urban Complexity: One-way roads, GPS errors, restricted zones.
              </li>
              <li>
                Multiple Objectives: Balancing speed, cost, and efficiency.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Faster Delivery: Shorter routes reduce delivery time.</li>
              <li>Cost Savings: Lower fuel and fleet maintenance costs.</li>
              <li>
                Customer Experience: Timely, accurate deliveries increase
                satisfaction.
              </li>
              <li>
                Sustainability: Reduces carbon footprint by minimizing miles.
              </li>
              <li>
                Scalability: Efficient handling of large delivery volumes.
              </li>
            </ul>

            <h5>Algorithm:</h5>
            <p>
              The A* (A-star) algorithm is a graph traversal and pathfinding
              technique that finds the shortest path between nodes by combining
              features of Dijkstra’s Algorithm and Greedy Best-First Search.
            </p>
            <p>
              It uses a cost function: <strong>f(n) = g(n) + h(n)</strong>,
              where:
            </p>
            <ul>
              <li>
                <strong>g(n)</strong> = actual cost from the start node to the
                current node
              </li>
              <li>
                <strong>h(n)</strong> = estimated cost from the current node to
                the goal (heuristic)
              </li>
            </ul>

            <p>
              <strong>Design Principle:</strong>
              A* prioritizes nodes that appear most promising—balancing known
              cost (<code>g(n)</code>) and estimated future cost
              (<code>h(n)</code>)—making it both complete and optimal with an
              admissible heuristic.
            </p>

            <h5>Real-Time Example:</h5>
            <p>
              Scout robot delivers 5 packages. It reroutes due to construction,
              one-way roads, GPS drop, and low battery.
            </p>
            <ul>
              <li>Models city as a graph.</li>
              <li>Finds shortest, cost-efficient path.</li>
              <li>Reroutes in real-time with changing conditions.</li>
            </ul>
            <p>Heuristics Used:</p>
            <ul>
              <li>Manhattan Distance (best for grid roads)</li>
              <li>Euclidean Distance (if diagonal moves allowed)</li>
              <li>Time-based heuristic (traffic delays)</li>
              <li>Energy-based heuristic (battery usage)</li>
            </ul>
            <h5>A* Algorithm Analysis:</h5>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(E) worst case; O(log N) if
                heuristic is perfect
              </li>
              <li><strong>Space Complexity:</strong> O(V) for storing nodes</li>
              <li>
                <strong>Optimality:</strong> Optimal with admissible heuristic;
                complete on finite graphs
              </li>
              <li>
                <strong>Heuristic Impact:</strong> Good heuristics speed up
                search; poor ones slow it to Dijkstra’s
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/A*tree.c"
              style="font-size: 20px"
              >view code here</a
            >

            <img
              src="gif/AstarExampleEn.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>
              3. Smart Aerial Logistics Optimization System(Amazon Prime Air –
              Drone Delivery)
            </h4>
            <p>
              A drone-based delivery system designed to deliver packages in
              under 30 minutes using AI-powered autonomous drones. The system
              dynamically plans flight routes, avoids obstacles, and optimizes
              for time and energy usage.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                Real-time Route Planning-Avoid weather, no-fly zones, obstacles.
              </li>
              <li>
                Battery Optimization-Energy-efficient paths, ensure return.
              </li>
              <li>Collision Avoidance-Avoid other drones, birds, buildings.</li>
              <li>
                Urban Navigation-Handle complex city layouts and airspace.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Ultra-fast delivery</li>
              <li>Reduced last-mile cost</li>
              <li>Reach rural/remote areas</li>
            </ul>

            <h5>Algorithm :A* tree</h5>
            <p>
              The A* algorithm is a popular pathfinding and graph traversal
              algorithm that finds the shortest path between nodes in a weighted
              graph. It combines features of Dijkstra's algorithm and Greedy
              Best-First Search by using both the actual cost from the start
              node and an estimated cost to the goal to guide the search
              efficiently.
            </p>

            <p>It uses a cost function:</p>
            <p><strong>f(n) = g(n) + h(n)</strong>, where:</p>
            <ul>
              <li>
                <strong>g(n)</strong> = actual cost from the start node to the
                current node
              </li>
              <li>
                <strong>h(n)</strong> = heuristic estimated cost from the
                current node to the goal
              </li>
            </ul>

            <p>
              The design principle is to explore nodes that minimize the total
              estimated path cost, prioritizing nodes that seem closer to the
              goal based on the heuristic while ensuring the shortest path.
            </p>
            <h5>Real-Time Usage Example with Heuristics</h5>
            <p><strong>Scenario:</strong></p>
            <ul>
              <li>
                An Amazon Prime Air drone must deliver a package 10 km away in a
                city.
              </li>
              <li>During the flight, it faces no-fly zones near hospitals.</li>
              <li>Sudden wind changes occur.</li>
              <li>Low battery triggers route optimization.</li>
              <li>Unexpected obstacles like cranes appear.</li>
            </ul>

            <p><strong>How A* Helps:</strong></p>
            <ul>
              <li>
                Models the 3D airspace as a grid graph (latitude, longitude,
                altitude).
              </li>
              <li>
                Uses Euclidean distance as the heuristic to estimate
                straight-line distance to the goal.
              </li>
              <li>
                Adds environmental penalties in the heuristic for obstacles or
                weather conditions to avoid risky paths.
              </li>
              <li>
                Dynamically recalculates the route to avoid no-fly zones and
                conserve battery.
              </li>
            </ul>
            <h5>Algorithm Analysis</h5>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(b<sup>d</sup>), where b =
                branching factor, d = depth; higher in 3D space
              </li>
              <li>
                <strong>Space Complexity:</strong> O(V), where V is the number
                of nodes/grid points
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/A*tree.c"
              style="font-size: 20px"
              >view code here</a
            >

            <img
              src="gif/AstarExampleEn.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
            <img
              src="gif/797fbc19a8c889734ed4a8a76ff892bf.gif"
              alt="dijkstar Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>4.Product Recommendation System</h4>
            <p>
              system that suggests items to users based on their interests,
              behavior, and past interactions. On platforms like Amazon, it
              helps users find products they’re likely to buy by analyzing their
              purchase history, viewed or searched items, and the behavior of
              similar users. It also looks at how products are related to each
              other, such as items that are frequently bought together.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Scalability:</strong> Millions of products result in
                massive graphs, making computation intensive.
              </li>
              <li>
                <strong>Graph freshness:</strong> Recomputing PageRank scores
                frequently is resource-heavy and time-consuming.
              </li>
              <li>
                <strong>Sparsity:</strong> New or niche products often lack
                connections, causing cold start issues.
              </li>
              <li>
                <strong>Biases:</strong> Without normalization, popular products
                dominate the rankings unfairly.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Improved user experience:</strong> Leads to better
                recommendations and increased sales.
              </li>
              <li>
                <strong>Better visibility for niche products:</strong> Drives
                long-tail revenue growth.
              </li>
              <li>
                <strong>Trustworthy suggestions:</strong> Reduces the chances of
                manipulation and boosts user confidence.
              </li>
              <li>
                <strong>Cross-sell opportunities:</strong> Enables smart bundle
                recommendations for increased cart value.
              </li>
              <li>
                <strong>Higher engagement:</strong> Results in more time spent
                on the platform and higher conversion rates.
              </li>
            </ul>

            <h5>Algorithm :PageRank</h5>
            <p>
              The <strong>PageRank</strong> algorithm ranks nodes (products) in
              a graph by simulating a random walk through the network. It uses
              Markov chains to model the probability of moving from one node to
              another based on product relationships like co-purchases or views.
            </p>
            <p>The design principle combines:</p>
            <ul>
              <li>
                <strong>Iterative convergence:</strong> Repeatedly updates rank
                scores until stable.
              </li>
              <li>
                <strong>Damping factor:</strong> Introduces randomness to avoid
                rank sinks and simulate random jumps, improving exploration.
              </li>
              <li>
                <strong>Graph-based scoring:</strong> Leverages product link
                structure to assess importance and influence.
              </li>
            </ul>
            <p>
              This ensures highly connected and influential products receive
              higher ranks for better recommendations.
            </p>

            <h5>Real-Time Usage Example</h5>
            <p>
              Amazon models millions of products as nodes connected by edges
              representing user behavior (views, purchases, co-purchases). When
              a user views a product, PageRank scores help suggest other
              relevant products by:
            </p>
            <ul>
              <li>
                Highlighting popular and niche products based on connectivity.
              </li>
              <li>
                Dynamically updating recommendations as user interactions
                change.
              </li>
              <li>
                Supporting cross-selling by identifying frequently bought
                together product bundles.
              </li>
            </ul>

            <h5>Algorithm Analysis</h5>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(N + E) per iteration, where
                N is the number of products (nodes) and E is the number of edges
                (relationships).
              </li>
              <li>
                <strong>Space Complexity:</strong> O(N + E) to store the graph
                and rank scores.
              </li>
              <li>
                <strong>Scalability:</strong> Efficient for millions of products
                with sparse graphs and incremental updates.
              </li>
              <li>
                <strong>Optimality:</strong> Balances influence and relevance in
                product ranking.
              </li>
              <li>
                <strong>Challenges:</strong> Cold start for new products,
                mitigated by damping and normalization.
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/page_rank.c"
              style="font-size: 20px"
              >view code here</a
            >
            <img
              src="gif/Page_rank_animation.gif"
              alt="PageRank Algorithm"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>5. Inventory Management and Stock Allocation</h4>
            <p>
              Effective inventory management is essential for Amazon to ensure
              products are available when customers need them, without
              overstocking or incurring unnecessary storage costs. With millions
              of products and geographically distributed warehouses, Amazon
              needs a smart system that can decide which products to store in
              which locations. This system must account for factors like
              warehouse space, regional demand, shipping efficiency, and storage
              costs. By analyzing product value, space requirements, and demand
              trends, Amazon dynamically allocates stock across its warehouses
              to balance availability, reduce delivery times, and optimize
              overall operational efficiency.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                Large-scale inventory with multiple products and warehouses.
              </li>
              <li>Dynamic demand patterns and supply chain uncertainties.</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Reduces inventory holding costs and stockouts.</li>
              <li>Maximizes fulfillment efficiency.</li>
            </ul>

            <h5>Algorithm : 0/1 Knapsack</h5>
            <p>
              The <strong>0/1 Knapsack algorithm</strong> using Dynamic
              Programming (DP) is used to select the most valuable combination
              of items (products) that can fit within a limited capacity
              (warehouse space or budget). Each product has a value (e.g.,
              profit or demand level) and a weight (e.g., storage cost or
              space). The objective is to maximize the total value without
              exceeding the warehouse capacity.
            </p>

            <h5>Design Principle:</h5>
            <p>
              Dynamic Programming follows the principle of
              <strong>optimal substructure</strong> and
              <strong>overlapping subproblems</strong>. It builds solutions to
              larger problems by combining optimal solutions to smaller
              subproblems, storing intermediate results in a table to avoid
              redundant calculations.
            </p>

            <h5>Real-Time Usage Example:</h5>
            <p>
              Amazon receives inventory for 500 different products and must
              distribute them across 3 warehouses, each with limited space and
              regional demand. The goal is to:
            </p>
            <ul>
              <li>Prioritize popular items with high regional demand</li>
              <li>Stay within the storage limits of each warehouse</li>
              <li>Reduce delivery time by placing products closer to buyers</li>
            </ul>
            <p>
              The Knapsack algorithm helps Amazon decide the best set of
              products to allocate to each warehouse, balancing value (e.g.,
              demand/profit) and weight (e.g., storage size or cost).
            </p>

            <h5>Algorithm Analysis:</h5>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(N × W) where N is the number
                of products and W is the capacity of the warehouse
              </li>
              <li>
                <strong>Space Complexity:</strong> O(N × W) (can be optimized to
                O(W) with 1D array)
              </li>
              <li>
                <strong>Optimality:</strong> Produces optimal allocation for
                given constraints
              </li>
              <li>
                <strong>Scalability:</strong> Handles large inventory datasets
                effectively with proper optimizations
              </li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/knapsack.c"
              style="font-size: 20px"
              >view code here</a
            >
            <img
              src="gif/knapsack_tabulation.gif"
              alt="Prim's Algorithm in Action"
              width="600"
            />
          </div>

          <div class="use-case">
            <h4>6. Max-Flow Optimization for Prime Video Delivery</h4>
            <p>
              applying network flow optimization techniques to enhance the
              delivery of video content across Prime Video's infrastructure. The
              objective is to ensure efficient content distribution by
              minimizing latency, reducing bottlenecks, and optimizing the
              overall network performance, particularly under heavy load
              conditions.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Dynamic Traffic:</strong> Fluctuating user demand
                complicates real-time optimization.
              </li>
              <li>
                <strong>Complex Network:</strong> Large infrastructure increases
                optimization complexity.
              </li>
              <li>
                <strong>QoS Balance:</strong> Managing flow optimization while
                ensuring high video quality.
              </li>
              <li>
                <strong>Server Overload:</strong> Efficient load balancing is
                difficult.
              </li>
              <li>
                <strong>Reconfiguration Overhead:</strong> Frequent updates can
                disrupt service.
              </li>
              <li>
                <strong>Scalability:</strong> Handling growing user and content
                demand.
              </li>
              <li>
                <strong>External Issues:</strong> Network failures and
                restrictions can affect delivery.
              </li>
              <li>
                <strong>Privacy:</strong> Ensuring secure, privacy-compliant
                data flow.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Better User Experience:</strong> Faster streaming,
                reduced buffering.
              </li>
              <li>
                <strong>Cost Efficiency:</strong> Reduced infrastructure costs
                through optimal resource use.
              </li>
              <li><strong>Scalability:</strong> Seamless system growth.</li>
              <li>
                <strong>Efficiency:</strong> Improved server and bandwidth
                utilization.
              </li>
              <li>
                <strong>Competitive Edge:</strong> Enhanced content delivery
                attracts more users.
              </li>
              <li>
                <strong>Quick Content Delivery:</strong> Faster deployment,
                especially during peak times.
              </li>
              <li>
                <strong>Global Reliability:</strong> Consistent service across
                regions.
              </li>
              <li>
                <strong>Actionable Insights:</strong> Data-driven improvements
                in network strategy.
              </li>
            </ul>
            <h5>Algorithm Description: Ford-Fulkerson (Max-Flow)</h5>
            <p>
              Ford-Fulkerson finds the maximum flow in a network by repeatedly
              identifying augmenting paths from source to sink and pushing flow
              through them. It uses a residual graph to track remaining
              capacities and updates flows until no more paths can be found.
            </p>

            <h5>Design Principle:</h5>
            <ul>
              <li>
                <strong>Residual Graph:</strong> Tracks available capacity.
              </li>
              <li>
                <strong>Augmenting Paths:</strong> Found using DFS or BFS.
              </li>
              <li>
                <strong>Flow Updates:</strong> Flow is increased along valid
                paths.
              </li>
              <li><strong>Stops:</strong> When no augmenting paths remain.</li>
            </ul>
            <h5>Real-Time Usage:</h5>
            <p>
              In the context of <strong>Prime Video content delivery</strong>,
              Ford-Fulkerson helps optimize how video data flows across the
              global content delivery network (CDN).
            </p>
            <p>
              When millions of users stream simultaneously, Amazon must
              efficiently route data from servers to users with minimal
              buffering and latency. The delivery paths form a flow network with
              constraints like bandwidth and server capacity.
            </p>
            <p>Ford-Fulkerson can be applied to:</p>
            <ul>
              <li>
                <strong>Maximize video flow</strong> from central data centers
                to regional edge servers.
              </li>
              <li>
                <strong>Balance server loads</strong> by redistributing excess
                traffic through alternate paths.
              </li>
              <li>
                <strong>Minimize congestion</strong> by rerouting traffic when
                certain routes are overloaded.
              </li>
              <li>
                <strong>Ensure consistent quality</strong> even during peak
                streaming hours or failures in part of the network.
              </li>
            </ul>
            <h5>Algorithm Analysis:</h5>
            <p>
              The efficiency of the Ford-Fulkerson algorithm depends on the way
              augmenting paths are selected and the structure of the network.
            </p>
            <ul>
              <li>
                <strong>Time Complexity:</strong>
                In the worst case, the complexity is <code>O(E × f)</code>,
                where <code>E</code> is the number of edges and
                <code>f</code> is the maximum flow value. This can be slow when
                <code>f</code> is large, especially if path selection is
                inefficient.
              </li>
              <li>
                <strong>Space Complexity:</strong>
                Requires <code>O(V + E)</code> space, where <code>V</code> is
                the number of vertices and <code>E</code> the number of edges,
                to maintain the residual graph.
              </li>
              <li>
                <strong>Scalability:</strong>
                Suitable for medium-sized networks, but for real-time and
                high-demand systems like Prime Video, optimized versions such as
                Edmonds-Karp (using BFS) or Dinic’s Algorithm are preferred for
                faster and predictable performance.
              </li>
              <li>
                <strong>Accuracy:</strong>
                Guarantees optimal flow solution if capacities are integers.
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/ford_fulkerson.c"
              style="font-size: 20px"
              >View Kruskal's Code Here</a
            >
            <br />

            <img
              src="gif/ford.gif"
              alt="Prim's Algorithm in Action"
              width="600"
            />
          </div>
          <div class="use-case">
            <h4>7. Optimizing Warehouse and Fulfillment Center Network</h4>
            <p>
              Amazon has a massive network of fulfillment centers. MST can help
              design the most cost-effective communication or transportation
              network among warehouses.and Connects all warehouses with minimal
              total transportation cost or time.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                Changing demand regions may require dynamic MST adjustments.
              </li>
              <li>
                Real-world terrain and traffic factors complicate edge weights.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Reduces inter-warehouse transportation cost.</li>
              <li>Boosts delivery speed through strategic route planning.</li>
            </ul>
            <h5>Algorithm Description and Design Principle</h5>

            <p>
              <strong>Kruskal’s Algorithm:</strong> Kruskal’s algorithm is a
              greedy algorithm used to find the Minimum Spanning Tree (MST) of a
              connected, weighted graph. It focuses on selecting edges in
              increasing order of weight and adds them to the tree if they do
              not form a cycle.
            </p>
            <p>
              <strong>Design Principle:</strong> It uses the
              <em>Greedy Method</em>. The algorithm sorts all edges by weight
              and selects the smallest possible edge that connects two disjoint
              sets. A Union-Find (Disjoint Set) data structure is used to detect
              and avoid cycles.
            </p>

            <p>
              <strong>Prim’s Algorithm:</strong> Prim’s algorithm also finds the
              MST but starts from a single source vertex and grows the tree by
              adding the cheapest edge from the tree to a vertex not yet in the
              tree.
            </p>
            <p>
              <strong>Design Principle:</strong> It follows the
              <em>Greedy Method</em>. At each step, the algorithm picks the
              minimum weight edge that connects the growing MST to a vertex
              outside it. This is often implemented using a priority queue
              (min-heap) for efficiency.
            </p>

            <p>
              <strong>Both algorithms ensure:</strong> The network connects all
              nodes (warehouses or fulfillment centers) with the least total
              cost, no cycles, and full reachability.
            </p>

            <h5>Real-Time Usage Example:</h5>
            <p>
              Amazon operates a vast network of fulfillment centers across
              different regions. To deliver products quickly and efficiently,
              these centers must communicate and transport goods between one
              another.
            </p>
            <p>
              Suppose Amazon is planning to open 10 new fulfillment centers in a
              new region. Each center has potential routes (roads, shipping
              lanes, or air routes) connecting it with others. Each route has an
              associated transportation cost or average delivery time.
            </p>
            <p>
              Using <strong>Kruskal’s Algorithm</strong>, Amazon can sort all
              potential routes by cost and iteratively connect the centers to
              form a network with the <strong>minimum total cost</strong>,
              avoiding loops and unnecessary connections.
            </p>
            <p>
              Alternatively, <strong>Prim’s Algorithm</strong> can start from a
              central or high-volume warehouse and gradually build the optimal
              network outward by always connecting to the nearest unconnected
              center. This is helpful when expanding from a hub location.
            </p>
            <p>This helps Amazon:</p>
            <ul>
              <li>Reduce fuel and delivery expenses.</li>
              <li>Minimize shipping delays and rerouting.</li>
              <li>
                Build a scalable and cost-efficient logistics infrastructure.
              </li>
            </ul>
            <h5>🔍 Algorithm Analysis</h5>

            <p><strong>Kruskal’s Algorithm:</strong></p>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(E log E), where E is the
                number of edges. Sorting edges dominates the complexity.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(V + E), where V is the
                number of vertices, mainly due to storing edges and Union-Find
                data structures.
              </li>
              <li>
                <strong>Suitability:</strong> Efficient for sparse graphs with
                fewer edges compared to vertices.
              </li>
            </ul>

            <p><strong>Prim’s Algorithm:</strong></p>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(E + V log V) with a priority
                queue and adjacency list representation, where V is vertices and
                E is edges.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(V + E) for the graph
                storage and priority queue.
              </li>
              <li>
                <strong>Suitability:</strong> Performs well on dense graphs and
                when starting from a specific node.
              </li>
            </ul>

            <p>
              <strong>Overall:</strong> Both algorithms are effective for
              building minimal cost networks. Choice depends on graph density
              and implementation details.
            </p>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/kruskal.c"
              style="font-size: 20px"
              >View Kruskal's Code Here</a
            >
            <br />
            <img
              src="https://upload.wikimedia.org/wikipedia/commons/5/5c/UnionFindKruskalDemo.gif"
              alt="Kruskal's Algorithm in Action"
              width="600"
            />
            <br /><br />

            <!-- Prim's Algorithm -->
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/prims.c"
              style="font-size: 20px"
              >View Prim's Code Here</a
            >
            <br />
            <img
              src="gif/prims.gif"
              alt="Prim's Algorithm in Action"
              width="600"
            />
          </div>

          <div class="use-case">
            <h4>8. Product Popularity Analysis</h4>
            <p>
              An e-commerce platform logs all product purchases over time.
              Business analysts frequently ask:
              <strong
                >“Which product was purchased the most between time X and
                Y?”</strong
              >
              These queries are crucial for trend discovery, inventory control,
              and promotional campaigns.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>Large transaction volumes and frequent range queries</li>
              <li>
                Brute-force methods (O(NQ)) are too slow for real-time needs
              </li>
              <li>Constant reindexing is inefficient for static logs</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Fast analytics → real-time recommendations & dashboards</li>
              <li>Smarter inventory planning based on trending items</li>
              <li>Personalized promotions targeting popular products</li>
              <li>Reduced cloud/server costs through efficient computation</li>
              <li>Scalable architecture ready for millions of users</li>
            </ul>

            <h5>Algorithm: mo's algo</h5>

            <p>
              Mo’s Algorithm is an offline technique to answer multiple range
              queries (like sum, frequency, distinct count) efficiently on
              static arrays. It reorders queries to reduce redundant
              computation.
            </p>
            <ul>
              <li>Divide array into √N blocks</li>
              <li>Sort queries by blocks & endpoints</li>
              <li>Move L/R pointers and update result</li>
              <li>Answer each query in optimized order</li>
            </ul>
            <h5>Real-Time Example</h5>
            <p>
              An e-commerce app logs purchases. To find the most frequent
              product between two times, Mo's Algorithm processes all such
              queries efficiently, reducing delay in analytics and dashboards.
            </p>
            <h2>Performance Analysis</h2>
            <ul>
              <li><strong>Query Time (per query):</strong> O(√N) amortized</li>
              <li><strong>Total Time (N queries):</strong> O((N + Q) × √N)</li>
              <li>
                <strong>Space Complexity:</strong> O(N + M) (M = unique IDs)
              </li>
              <li><strong>Scalability:</strong> Excellent</li>
              <li><strong>Suitable For:</strong> Large static datasets</li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/mos.c"
              style="font-size: 20px"
              >view code here</a
            >

            <img
              src="gif/mo's.jpg"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>9. Prime Video — Fast Title/Description Search using KMP</h4>
            <p>
              When a user searches for a show or movie (e.g., types "time
              traveler"), Prime Video must quickly scan through millions of
              titles, descriptions, and subtitles to find matches.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Huge Data Volume:</strong> Scanning millions of titles,
                descriptions, and subtitles in real-time.
              </li>
              <li>
                <strong>Low Latency:</strong> Users expect search results in
                milliseconds.
              </li>
              <li>
                <strong>Multilingual Content:</strong> Handling searches in
                various languages (English, Spanish, Hindi, etc.).
              </li>
              <li>
                <strong>Exact vs Fuzzy Search:</strong> Users often type partial
                phrases or misspellings.
              </li>
              <li>
                <strong>Real-time Updates:</strong> New titles added daily —
                search needs to stay fresh.
              </li>
              <li>
                <strong>Memory and Compute:</strong> Efficiently handling large
                datasets without consuming too much resource.
              </li>
              <li>
                <strong>Relevance and Ranking:</strong> KMP finds matches, but
                doesn’t rank them by relevance.
              </li>
              <li>
                <strong>Subtitle Data:</strong> Subtitles are large; need
                optimized search across them.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Better User Retention:</strong> Fast search keeps users
                engaged.
              </li>
              <li>
                <strong>Increased Content Discovery:</strong> Helps users find
                more shows, increasing viewing time.
              </li>
              <li>
                <strong>Higher Revenue:</strong> More content discovery → more
                rentals, purchases, subscriptions.
              </li>
              <li>
                <strong>Competitive Advantage:</strong> Faster search improves
                user experience over competitors.
              </li>
              <li>
                <strong>Cost Optimization:</strong> Reduces infrastructure costs
                by avoiding large search engines.
              </li>
              <li>
                <strong>Global Expansion:</strong> Attracts users in emerging
                markets with low bandwidth.
              </li>
              <li>
                <strong>Scalability:</strong> Easy to scale with Prime Video’s
                growing library.
              </li>
              <li>
                <strong>Supports Personalization:</strong> Lays foundation for
                personalized recommendations.
              </li>
            </ul>

            <h5>Algorithm: KMP</h5>
            <p>
              <strong>Algorithm Description:</strong> KMP efficiently searches
              for a pattern in text by preprocessing the pattern to build a
              Longest Prefix Suffix (LPS) table. This allows skipping redundant
              checks, making the search run in linear time
              <code>O(N + M)</code>, where N is text length and M is pattern
              length.
            </p>

            <p>
              <strong>Design Principles:</strong> KMP preprocesses the pattern
              to create the LPS table, avoids backtracking in the text, and uses
              a state-machine-like approach to shift the pattern intelligently.
              It balances a small memory cost <code>O(M)</code> with fast search
              speed.
            </p>
            <p>
              <strong>Real-Time Usage Example:</strong> When a user types a
              query like “time traveler” on Prime Video, KMP quickly scans
              millions of titles, descriptions, and subtitles to find matches,
              supporting instant search suggestions and multilingual content
              efficiently.
            </p>

            <p>
              <strong>Performance:</strong> Best, average, and worst-case time
              complexity is <code>O(N + M)</code>, with linear memory
              <code>O(M)</code> for the LPS table. This makes KMP scalable and
              ideal for real-time, large-scale substring searches.
            </p>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/kmp.c"
              style="font-size: 20px"
              >view code here</a
            >

            <img
              src="gif/kmp-algorithm-approach.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>10. Amazon Product Search and Ranking Optimization</h4>

            <p>
              When customers search for products, Amazon needs to display
              results that are most relevant to the user, based on factors such
              as price, reviews, relevance, or popularity.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Ranking and Relevance:</strong> Balancing multiple
                factors like price, reviews, and popularity for accurate
                results.
              </li>
              <li>
                <strong>Personalization:</strong> Tailoring search results based
                on user preferences and browsing history.
              </li>
              <li>
                <strong>Query Understanding:</strong> Interpreting user intent,
                especially with vague or misspelled searches.
              </li>
              <li>
                <strong>Product Data Management:</strong> Ensuring accurate,
                consistent, and up-to-date product information.
              </li>
              <li>
                <strong>Scalability:</strong> Handling a large product catalog
                while maintaining fast, real-time search performance.
              </li>
              <li>
                <strong>External Factors:</strong> Adapting to seasonal changes,
                promotions, and availability.
              </li>
              <li>
                <strong>Multilingual Search:</strong> Managing language and
                cultural differences in global markets.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Increased Conversion Rates:</strong> Relevant search
                results lead to more purchases.
              </li>
              <li>
                <strong>Customer Satisfaction:</strong> A personalized search
                experience boosts loyalty and retention.
              </li>
              <li>
                <strong>Better Discoverability:</strong> Customers find more
                products, expanding their shopping options.
              </li>
              <li>
                <strong>Higher Revenue:</strong> Optimized search can drive
                sales, especially for popular products.
              </li>
              <li>
                <strong>Brand Reputation:</strong> A smooth search process
                strengthens Amazon's brand and attracts more customers.
              </li>
              <li>
                <strong>Cost Efficiency:</strong> Reduced search overhead saves
                computational resources.
              </li>
              <li>
                <strong>Data Insights:</strong> Provides valuable user data for
                inventory and marketing decisions.
              </li>
              <li>
                <strong>Competitive Advantage:</strong> A superior search system
                differentiates Amazon from competitors.
              </li>
            </ul>

            <h5>Algorithm: Tim sort</h5>

            <ul>
              <li>
                <strong>Description:</strong> Hybrid sorting algorithm combining
                Merge Sort and Insertion Sort that detects naturally ordered
                <em>runs</em> and merges them efficiently.
              </li>
              <li>
                <strong>Design Principles:</strong>
                <ul>
                  <li>Adapts by detecting runs and merging them optimally.</li>
                  <li>
                    Balances divide-and-conquer with insertion sort for nearly
                    sorted data.
                  </li>
                  <li>
                    Maintains stability to preserve order of equal elements.
                  </li>
                  <li>
                    Uses stack-based merging for performance and efficiency.
                  </li>
                </ul>
              </li>
              <li>
                <strong>Real-Time Usage:</strong>
                <ul>
                  <li>
                    Sorts millions of Amazon products by price, reviews, and
                    popularity.
                  </li>
                  <li>
                    Excels on partially sorted data due to caching or prior
                    queries.
                  </li>
                  <li>
                    Delivers stable and fast sorting for smooth user experience.
                  </li>
                </ul>
              </li>
              <li>
                <strong>Performance:</strong>
                <ul>
                  <li>Best Case: <code>O(n)</code> on nearly sorted data.</li>
                  <li>Average & Worst Case: <code>O(n log n)</code>.</li>
                  <li>Space Complexity: <code>O(n)</code> for merging.</li>
                  <li>
                    Highly efficient and stable — used in Python’s
                    <code>sorted()</code> and Java’s <code>Arrays.sort()</code>.
                  </li>
                </ul>
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/tim_sort.c"
              style="font-size: 20px"
              >view code here</a
            >
            <img
              src="gif/timsort.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>11. Autocomplete in Amazon Search</h4>
            <p>
              When users start typing a query in Amazon’s search bar, the
              Autocomplete feature suggests relevant products, categories, or
              popular search terms in real-time, helping users quickly find what
              they're looking for without having to type the full query.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Handling Large Datasets:</strong> Efficiently processing
                vast data for real-time suggestions.
              </li>
              <li>
                <strong>Personalization at Scale:</strong> Accurately
                personalizing for millions of users.
              </li>
              <li>
                <strong>Query Understanding:</strong> Interpreting partial input
                and providing meaningful suggestions.
              </li>
              <li>
                <strong>Response Time:</strong> Maintaining fast suggestions
                without affecting UX.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Faster Search:</strong> Quick, relevant results improve
                user satisfaction.
              </li>
              <li>
                <strong>Increased Conversions:</strong> Relevant suggestions
                lead to higher purchase rates.
              </li>
              <li>
                <strong>Better User Engagement:</strong> Personalized
                suggestions keep users engaged with the platform.
              </li>
            </ul>

            <h5>Algorithm:Trie (Prefix Tree)</h5>
            <p>
              <strong>Description:</strong> Trie is a tree-based data structure
              that stores strings by breaking them into characters and
              organizing them in a prefix-based hierarchy. It allows fast
              retrieval of all words sharing a common prefix, making it ideal
              for autocomplete features.
            </p>

            <p><strong>Design Principles:</strong></p>
            <ul>
              <li>
                <strong>Divide and Conquer:</strong> Splits strings into
                characters (divide) and inserts them into a hierarchical tree
                (conquer) for efficient storage and retrieval.
              </li>
              <li>
                <strong>Prefix Sharing:</strong> Common prefixes are stored only
                once, reducing memory usage.
              </li>
              <li>
                <strong>Efficient Search:</strong> Quickly finds all suggestions
                starting with the input prefix by traversing the tree.
              </li>
              <li>
                <strong>Scalability:</strong> Handles very large datasets of
                strings efficiently.
              </li>
            </ul>
            <p>
              <strong>Real-Time Usage Example:</strong> In Amazon’s search
              autocomplete, the Trie structure stores millions of product names,
              categories, and popular search terms. As users type each
              character, the Trie efficiently retrieves relevant suggestions
              instantly, improving user experience by reducing typing effort and
              speeding up product discovery.
            </p>

            <p><strong>Performance Analysis:</strong></p>
            <ul>
              <li>
                <strong>Insertion Time:</strong> O(k), where k is the length of
                the string inserted.
              </li>
              <li>
                <strong>Search Time:</strong> O(k), where k is the length of the
                input prefix.
              </li>
              <li>
                <strong>Memory Usage:</strong> Can be high but optimized by
                sharing common prefixes.
              </li>
              <li>
                <strong>Suitability:</strong> Excellent for real-time
                prefix-based search and autocomplete.
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/trie.c"
              style="font-size: 20px"
              >view code here</a
            >
            <img
              src="gif/trie.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>12.Stable Driver-Warehouse Assignment during Prime Day</h4>
            <p>
              During major sales events like Prime Day, Amazon needs to match
              thousands of drivers to dozens of warehouses efficiently. Drivers
              have preferences (like closer warehouses, better shift times), and
              warehouses have preferences (drivers with better availability,
              experience).
            </p>
            <p>
              Using the *Gale-Shapley Stable Matching Algorithm, Amazon ensures
              that assignments are **stable* — meaning no driver and warehouse
              would rather switch partners after the initial assignment — which
              reduces chaos, improves delivery speeds, and ensures high
              satisfaction for both sides.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Massive Scale:</strong> Handling thousands of drivers
                and multiple warehouses in real-time.
              </li>
              <li>
                <strong>Dynamic Preferences:</strong> Drivers' and warehouses'
                preferences can change (last-minute cancellations, traffic
                updates).
              </li>
              <li>
                <strong>Fairness vs. Optimization:</strong> Balancing drivers'
                happiness with warehouses' operational needs.
              </li>
              <li>
                <strong>Time Sensitivity:</strong> Assignments must happen
                quickly to avoid delivery delays.
              </li>
              <li>
                <strong>Unexpected Events:</strong> Weather, traffic jams, or
                sudden surge in demand can disrupt initial stable assignments.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Operational Stability:</strong> Reduces chaos and
                last-minute reassignments during high-pressure events.
              </li>
              <li>
                <strong>Higher Driver Satisfaction:</strong> Happier drivers are
                more likely to stay and perform better.
              </li>
              <li>
                <strong>Faster Deliveries:</strong> Efficient driver-warehouse
                pairing leads to quicker and more reliable deliveries.
              </li>
              <li>
                <strong>Cost Efficiency:</strong> Reduces costs from overtime,
                rescheduling, and route reassignments.
              </li>
              <li>
                <strong>Competitive Advantage:</strong> Helps Amazon maintain
                its reputation for lightning-fast delivery even during massive
                sales events.
              </li>
            </ul>

            <h5>Algorithm: Gale-Shapley Stable Matching Algorithm</h5>
            <p>
              The
              <strong>Gale-Shapley Stable Matching Algorithm</strong> matches
              drivers and warehouses based on preferences to ensure a
              <em>stable</em> assignment where no pair would prefer to switch
              partners. This reduces conflicts and improves delivery efficiency.
            </p>

            <h5>Design Principles:</h5>
            <ul>
              <li>
                <p>
                  <strong>Stable Matching:</strong> No pair prefers each other
                  over assigned matches.
                </p>
              </li>
              <li>
                <p>
                  <strong>Preference Lists:</strong> Rankings based on location,
                  shifts, and experience.
                </p>
              </li>
              <li>
                <p>
                  <strong>Greedy Proposal:</strong> Drivers propose; warehouses
                  accept or reject.
                </p>
              </li>
              <li>
                <p>
                  <strong>Fairness & Adaptability:</strong> Matches respect
                  mutual preferences and adjust to changes.
                </p>
              </li>
            </ul>

            <h5>Real-Time Example: Stable Driver-Warehouse Assignment</h5>
            <p>
              <strong>Scenario:</strong> Amazon prepares for Prime Day with:
            </p>
            <ul>
              <li>5 Warehouses (W1–W5)</li>
              <li>5 Drivers (D1–D5)</li>
            </ul>
            <p><strong>Driver Preferences Based On:</strong></p>
            <ul>
              <li>Distance from home</li>
              <li>Shift timing</li>
              <li>Facility ratings</li>
            </ul>
            <p><strong>Warehouse Preferences Based On:</strong></p>
            <ul>
              <li>Driver availability</li>
              <li>On-time delivery history</li>
              <li>Experience</li>
            </ul>
            <p>
              <em
                >Gale-Shapley algorithm matches drivers and warehouses to ensure
                stable and efficient assignments.</em
              >
            </p>

            <h5>Performance Analysis:</h5>
            <ul>
              <li>
                <p>
                  <strong>Time Complexity:</strong> O(n²) for n drivers and
                  warehouses.
                </p>
              </li>
              <li>
                <p>
                  <strong>Space Complexity:</strong> O(n + m) for preference
                  storage.
                </p>
              </li>
              <li>
                <p>
                  <strong>Stability & Fairness:</strong> Guarantees stable
                  matches with slight proposer bias.
                </p>
              </li>
              <li>
                <p>
                  <strong>Scalability & Adaptation:</strong> Efficient and
                  handles dynamic changes.
                </p>
              </li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/gale_shapely.c"
              style="font-size: 20px"
              >view code here</a
            >

            <img
              src="gif/stable marriage.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            />
          </div>

          <div class="use-case">
            <h4>13. Secure Payment Encryption (Amazon Pay)</h4>
            <p>
              <strong>Problem:</strong> Encrypting customer card information
              quickly and securely during high-volume events like Prime Day.
            </p>
            <p>
              <strong>How FLT Helps:</strong> Fermat's Little Theorem optimizes
              modular arithmetic used in encryption algorithms like RSA, making
              encryption and decryption faster.
            </p>

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Scalability:</strong> Handling high-volume transactions.
              </li>
              <li><strong>Key Management:</strong> Secure key storage.</li>
              <li>
                <strong>Performance vs. Security:</strong> Balancing speed and
                security.
              </li>
              <li>
                <strong>Real-time Processing:</strong> Quick encryption without
                delays.
              </li>
              <li>
                <strong>Cryptanalysis:</strong> Defending against future threats
                (e.g., quantum computing).
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Faster Transactions:</strong> Optimized encryption
                speeds up the checkout process.
              </li>
              <li>
                <strong>Enhanced Security:</strong> Strong encryption protects
                customer data.
              </li>
              <li>
                <strong>Scalability:</strong> Handles large volumes without
                performance hits.
              </li>
              <li>
                <strong>Customer Trust:</strong> Increased consumer confidence
                and loyalty.
              </li>
              <li>
                <strong>Cost Savings:</strong> Efficient encryption reduces
                resource costs.
              </li>
            </ul>

            <h5>Selected Algorithm: RSA (with FLT Optimization)</h5>

            <p>
              <strong>Algorithm:</strong> RSA is a public-key encryption method
              using a public-private key pair. Fermat’s Little Theorem (FLT)
              speeds up modular inverse calculations during key generation and
              decryption.
            </p>

            <p>
              <strong>Design Principle:</strong> Large primes <code>p</code> and
              <code>q</code> generate <code>n = pq</code>. The public key
              <code>e</code> encrypts data, and the private key
              <code>d</code> decrypts using <code>FLT</code> for faster
              performance.
            </p>

            <p>
              <strong>Real-Time Usage:</strong> During Prime Day, Amazon uses
              RSA (with FLT) to encrypt the AES session key used to protect card
              info in Amazon Pay. This ensures fast, secure, and scalable
              transactions under high load.
            </p>

            <p><strong>Performance Efficiency:</strong></p>
            <ul>
              <li>
                <strong>Faster Computation:</strong> FLT accelerates modular
                inverse operations.
              </li>
              <li>
                <strong>Time Complexity:</strong> O(n³), but improved in
                practice with FLT.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(n), mainly for key storage.
              </li>
              <li>
                <strong>Scalability:</strong> Efficient under high-volume
                transactions (e.g., Prime Day).
              </li>
              <li>
                <strong>Security:</strong> Strong encryption using large primes
                makes it resistant to brute-force attacks.
              </li>
              <li>
                <strong>Fault Tolerance:</strong> Can re-initiate encryption if
                key issues occur.
              </li>
            </ul>
            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/flt.c"
              style="font-size: 20px"
              >view code here</a
            >

            <!-- <img
              src="https://media.giphy.com/media/ToMjGpS8DH4LEYhQ3qU/giphy.gif"
              alt="A* Algorithm Visualization"
              width="600"
              height="400"
            /> -->
          </div>
          <div class="use-case">
            <h4>14.Real-Time Product Catalog Search Optimization</h4>
            <p>
              In an e-commerce platform like Amazon, millions of products are
              added, updated, or removed daily. Customers expect fast and
              accurate search results, personalized recommendations, and smooth
              navigation through a vast and constantly changing product catalog.
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>Huge and constantly changing product catalog</li>
              <li>
                Complex queries combining keywords, categories, and multiple
                filters
              </li>
              <li>Real-time updates with minimal delay</li>
              <li>Low latency requirements for instant search results</li>
              <li>Scalability to support millions of users simultaneously</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Faster Search Results:</strong> Improves user
                satisfaction and reduces bounce rates
              </li>
              <li>
                <strong>Personalized Experience:</strong> Real-time suggestions
                and filters increase engagement
              </li>
              <li>
                <strong>Lower Infrastructure Costs:</strong> Efficient data
                structures reduce computational overhead
              </li>
              <li>
                <strong>Higher Conversion Rates:</strong> Users find relevant
                products quicker, boosting sales
              </li>
              <li>
                <strong>Competitive Advantage:</strong> Real-time, scalable
                search strengthens platform leadership
              </li>
            </ul>

            <h5>Algorithm: B-Tree</h5>
            <p>
              B-Trees are balanced tree data structures optimized for systems
              that read and write large blocks of data, such as databases and
              file systems. Unlike binary trees, B-Trees can have multiple keys
              and children per node, which reduces the tree height and improves
              search, insert, and delete operations. This makes B-Trees highly
              suitable for indexing large datasets like Amazon’s product
              catalog, where quick lookups and real-time updates are
              essential.<br />

              <strong>Design Principle:</strong> B-Trees use a balanced
              multi-way tree structure optimized for systems with large blocks
              of data (like disk or memory pages). They maintain sorted data and
              support efficient insertion, deletion, and search operations by
              keeping all leaf nodes at the same depth, minimizing tree height
              and ensuring logarithmic time complexity for operations.
            </p>

            <h5>Usage</h5>
            <p>
              <strong>A seller adds <em>"iPhone 15 Pro"</em> to Amazon.</strong
              ><br />
              The product is inserted into the B-Tree catalog index in sorted
              order.<br />
              Done in <strong>O(log n)</strong> time.
            </p>
            <p>
              <strong>Later, the seller removes the product.</strong><br />
              The B-Tree deletes the entry and rebalances the tree if needed.<br />
              Ensures <strong>fast search</strong> and an
              <strong>organized catalog</strong>.
            </p>
            <!-- Analysis Section -->

            <h5>Analysis</h5>
            <p>
              B-Trees ensure <strong>logarithmic performance</strong> for all
              key operations:
            </p>
            <ul>
              <li>
                <strong>Search:</strong> O(log n) — Fast lookups through
                balanced tree levels.
              </li>
              <li>
                <strong>Insertion:</strong> O(log n) — Inserts product data
                without re-scanning entire catalog.
              </li>
              <li>
                <strong>Deletion:</strong> O(log n) — Efficient removal with
                minimal restructuring.
              </li>
              <li>
                <strong>Balanced Structure:</strong> Automatically maintains
                balance even with frequent updates.
              </li>
              <li>
                <strong>Disk-Efficient:</strong> Fewer reads/writes due to
                multi-key nodes and compact indexing.
              </li>
            </ul>
            <p>
              This makes B-Trees ideal for large-scale systems like
              <strong>Amazon’s product catalog</strong>, where real-time updates
              and fast access are critical.
            </p>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <img
              src="gif/btree.gif"
              width="100%"
              height="600px"
              style="border: none"
            />
          </div>

          <div class="use-case">
            <h4>15. Dynamic Resource Load Detection – AWS CloudWatch</h4>
            <p>
              <strong>Use Case:</strong> Analyzing CPU, memory, and I/O usage
              across servers and time to detect high-load zones in real-time
              using AWS CloudWatch heatmaps.
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->
            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Scalability:</strong> Monitoring thousands of metrics
                across regions in real-time.
              </li>
              <li>
                <strong>Real-Time Alerts:</strong> Detecting spikes quickly to
                prevent downtime.
              </li>
              <li>
                <strong>Noise Filtering:</strong> Avoiding false positives from
                temporary spikes.
              </li>
              <li>
                <strong>Data Volume:</strong> Processing large matrices
                continuously and efficiently.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Autoscaling Optimization:</strong> Automatically
                triggers scaling in high-load zones.
              </li>
              <li>
                <strong>Improved SLA:</strong> Maintains service reliability
                with faster anomaly detection.
              </li>
              <li>
                <strong>Resource Efficiency:</strong> Identifies overprovisioned
                or underutilized resources.
              </li>
              <li>
                <strong>Operational Cost Savings:</strong> Reduces downtime and
                manual interventions.
              </li>
              <li>
                <strong>Customer Satisfaction:</strong> Ensures consistent
                performance during traffic surges.
              </li>
            </ul>

            <h5>Algorithm: 2D Kadane</h5>
            <p>
              <strong>Algorithm Description:</strong>
              2D Kadane’s Algorithm finds the submatrix with the maximum sum in
              a 2D matrix. It extends the 1D Kadane’s algorithm by fixing column
              pairs and applying 1D Kadane on row sums.
            </p>
            <p>
              <strong>Design Principle:</strong> - Convert 2D matrix to 1D row
              sums between two columns.<br />
              - Use 1D Kadane on this row array to find the maximum sum
              subarray.<br />
              - Repeat for all column pairs to find the submatrix with the
              highest load.
            </p>
            <h5>Usage</h5>
            <p>
              <strong>Scenario:</strong> CloudWatch monitors 100 EC2 servers
              every minute, forming a 100×1440 matrix (servers × minutes).
            </p>

            <p>
              <strong>Use of 2D Kadane:</strong> Finds the submatrix (e.g., 10
              servers over 30 minutes) with the highest CPU usage.
            </p>

            <p><strong>Why it matters:</strong></p>
            <ul>
              <li>Identifies performance bottlenecks</li>
              <li>Detects DDoS or unusual spikes</li>
              <li>Enables smart autoscaling actions</li>
            </ul>

            <p><strong>Performance Analysis:</strong></p>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(n³) for n×n matrices –
                significantly faster than brute-force O(n⁴).
              </li>
              <li>
                <strong>Space Complexity:</strong> O(n) – uses 1D temporary
                arrays.
              </li>
              <li>
                <strong>Efficiency:</strong> Real-time detection of load spikes
                without exhaustive scanning.
              </li>
              <li>
                <strong>Scalability:</strong> Effective for mid-sized matrices;
                further optimization can be done with parallelism in large-scale
                systems.
              </li>
              <li>
                <strong>Accuracy:</strong> Detects largest contiguous hotspots,
                helping avoid partial spike misses.
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <img
              src="gif/2dkadane.gif"
              width="100%"
              height="600px"
              style="border: none"
            />
          </div>

          <div class="use-case">
            <h4>16.Tracking Viewing Progress in Prime Video</h4>
            <h2>Description</h2>
            <p>
              Prime Video tracks each user’s viewing progress in real time to
              enable features like “Continue Watching” and personalized
              recommendations. It keeps a history of interactions to:
            </p>
            <ul>
              <li>Resume content accurately across devices</li>
              <li>Analyze viewing patterns and binge behavior</li>
              <li>Optionally revert to previous watch states</li>
            </ul>
            <p>
              This ensures a seamless and personalized streaming experience.
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>Efficient progress tracking without data duplication</li>
              <li>Fast retrieval of current and past viewing states</li>
              <li>Cross-device sync and rollback support</li>
              <li>Minimal storage use</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Better user experience and retention</li>
              <li>Smarter, data-driven recommendations</li>
              <li>Deeper engagement insights</li>
              <li>Scalable and reliable platform</li>
            </ul>

            <h5>Algorithm: Persistent Segment Tree</h5>

            <p>
              A Persistent Segment Tree keeps all past versions after updates by
              creating new versions instead of overwriting data. This enables
              efficient queries on any previous state, useful for tracking
              changes or undoing updates.
            </p>
            <ul>
              <li>
                <strong>Partial Copying:</strong> Only nodes on the update path
                are copied to create a new version, saving memory.
              </li>
              <li>
                <strong>Immutable Versions:</strong> Each version is fixed and
                safe to query without affecting others.
              </li>
              <li>
                <strong>Fast Operations:</strong> Updates and queries run in
                O(log n) time per version.
              </li>
              <li>
                <strong>Space Efficient:</strong> Shares unchanged nodes between
                versions to reduce memory use.
              </li>
            </ul>

            <h5>Usage</h5>
            <p>
              It saves each update as a new version by copying only changed
              parts of the tree. Old versions stay unchanged and can be queried
              anytime.
            </p>

            <ul>
              <li>User starts watching (progress = 0).</li>
              <li>Watches 10 minutes → new version created.</li>
              <li>Pauses at 15 minutes → another new version created.</li>
              <li>Platform can check any version for past progress.</li>
              <li>
                User switches devices → system quickly loads latest progress.
              </li>
              <li>Rollback to previous versions if needed.</li>
            </ul>
            <!-- Analysis Section -->

            <h5>Analysis</h5>
            <ul>
              <li><strong>Update & Query:</strong> O(log n) time each</li>
              <li>
                <strong>Space:</strong> O(n log n) for n versions (only changed
                nodes copied)
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <img
              src="gif/persistant segment tree.png"
              width="100%"
              height="600px"
              style="border: none"
            />
          </div>
          <div class="use-case">
            <h4>17.Efficient Resource Usage Monitoring in AWS Cloud</h4>
            <p>
              AWS monitors CPU, memory, and network usage for thousands of cloud
              instances in real time. To support fast billing, health checks,
              and anomaly detection, the system must frequently query usage over
              time intervals
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>High-frequency data from thousands of sources</li>
              <li>Frequent interval-based queries</li>
              <li>Low-latency requirements</li>
              <li>Need for simplicity at scale</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Real-time billing visibility</li>
              <li>Instant anomaly alerts</li>
              <li>Efficient and scalable monitoring</li>
            </ul>

            <h5>Algorithm:Square Root Decomposition</h5>
            <p>
              Square Root Decomposition is a range query optimization technique
              used to preprocess an array for faster query and update
              operations. It divides the array into √n-sized blocks, allowing
              queries and updates to be executed faster than brute-force
              approaches.
            </p>
            <p>Design principle</p>
            <ul>
              <li>Divide array of size n into √n blocks</li>
              <li>Precompute aggregates per block</li>
              <li>Use partial + block sums for range queries</li>
            </ul>
            <h5>Usage</h5>

            <p>
              <strong>Problem:</strong> Track CPU/memory usage for EC2 over time
              ranges like 1PM–3PM, needed for billing and alerts.
            </p>
            <p><strong>Square Root Decomposition:</strong></p>
            <ul>
              <li>Fast usage queries with low latency</li>
              <li>Supports real-time billing and anomaly detection</li>
              <li>Simple and scalable for mid-scale systems</li>
            </ul>
            <!-- Analysis Section -->

            <h5>Analysis</h5>

            <ul>
              <li><strong>Preprocessing Time:</strong> O(n)</li>
              <li><strong>Range Query Time:</strong> O(√n)</li>
              <li><strong>Update Time:</strong> O(√n) (worst case)</li>
              <li><strong>Space Complexity:</strong> O(n)</li>
            </ul>
            <p>
              <strong>✅ Pros:</strong> Simple to implement, memory-efficient,
              good for moderate queries and updates.
            </p>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <img
              src="gif/squareroot-decomposition.png"
              width="100%"
              height="600px"
              style="border: none"
            />
          </div>
          <div class="use-case">
            <h4>
              18.Customer Purchase Clustering for Product Recommendation and A/B
              Testing
            </h4>
            <p>
              In Amazon’s vast eCommerce ecosystem, millions of users make
              purchases daily. Identifying clusters of users who frequently buy
              similar sets of items can help Amazon:
            </p>
            <ul>
              <li>Recommend more relevant products (cross-sell/up-sell).</li>
              <li>
                Perform targeted A/B testing for personalization strategies.
              </li>
              <li>Improve collaborative filtering accuracy.</li>
            </ul>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>
                <strong>Scalability:</strong> Millions of users and billions of
                transactions make traditional clustering slow.
              </li>
              <li>
                <strong>Dynamic Behavior:</strong> Users constantly change their
                purchase preferences.
              </li>
              <li>
                <strong>Similarity Detection:</strong> Quickly finding similar
                users is computationally expensive.
              </li>
              <li>
                <strong>Low Latency:</strong> Recommendations need to be made in
                real-time.
              </li>
              <li>
                <strong>Memory Efficiency:</strong> Massive data volumes require
                efficient data structures.
              </li>
              <li>
                <strong>Cluster Tracking:</strong> Updating and maintaining user
                clusters is complex.
              </li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>
                <strong>Increased Revenue:</strong> Personalized bundles drive
                more purchases.
              </li>
              <li>
                <strong>Smarter A/B Testing:</strong> Experiments based on
                behavioral clusters are more accurate.
              </li>
              <li>
                <strong>Real-Time Personalization:</strong> Instant
                recommendations improve user engagement.
              </li>
              <li>
                <strong>Efficient Infrastructure:</strong> Low computational
                overhead reduces server cost.
              </li>
              <li>
                <strong>Higher Engagement:</strong> Relevant content boosts
                interaction.
              </li>
              <li>
                <strong>Improved Retention:</strong> Clusters enable
                loyalty-based offers and retention strategies.
              </li>
            </ul>

            <h5>Algorithm: Union-Find</h5>
            <p>
              The Union-Find (Disjoint Set Union) algorithm is a data structure
              that manages a collection of non-overlapping sets. It supports two
              primary operations:
            </p>
            <ul>
              <li>
                <strong>find(x):</strong> Finds the leader (representative) of
                the set containing <code>x</code>.
              </li>
              <li>
                <strong>union(x, y):</strong> Merges the sets containing
                <code>x</code> and <code>y</code>.
              </li>
            </ul>
            <p>
              Union-Find works by dynamically grouping elements into disjoint
              sets with efficient merging (union) and fast lookup (find),
              optimizing the data structure via balanced tree linking and path
              compression to achieve near-constant time operations.
            </p>
            <h5>Usage</h5>
            <p>
              Each user is represented as a node. When two users have similar
              purchase histories (e.g., 80% Jaccard similarity), a union
              operation is triggered to group them.
            </p>
            <p>When a user purchases a new item, the system:</p>
            <ul>
              <li>Calculates similarity with other users.</li>
              <li>Performs <code>union()</code> if similarity is high.</li>
              <li>Uses <code>find()</code> to identify the cluster.</li>
              <li>Recommends items from that user’s cluster.</li>
              <li>Targets clusters for personalized A/B testing.</li>
            </ul>

            <h5>Analysis</h5>
            <p>The Union-Find algorithm is extremely efficient:</p>
            <ul>
              <li>
                <strong>find(x):</strong> In worst-case O(n), but optimized to
                nearly constant time O(α(n)) using path compression.
              </li>
              <li>
                <strong>union(x, y):</strong> Also optimized to O(α(n)) with
                union by rank.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(n), where <code>n</code> is
                the number of users.
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <img
              src="gif/UnionFindKruskalDemo.gif"
              width="100%"
              height="600px"
              style="border: none"
            />
          </div>

          <div class="use-case">
            <h4>19.Robot Navigation in Amazon Warehouses</h4>
            <p>
              Amazon’s robotic fulfillment centers deploy autonomous robots to
              transport items between storage shelves and packing stations. The
              warehouse floor is divided into cells, each with varying movement
              costs depending on factors such as aisle width, floor conditions,
              or congestion. Unlike traditional shortest path algorithms, the
              goal is to find the path that minimizes total energy consumption
              or movement cost rather than just distance.
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>
                Variable movement costs per cell (narrow aisles, slippery
                floors).
              </li>
              <li>Dynamic obstacles and congestion.</li>
              <li>No reliable heuristics for real-time path costs.</li>
              <li>Need for energy-efficient routes.</li>
              <li>Safety to avoid risky zones.</li>
              <li>Scalability for many robots simultaneously.</li>
            </ul>

            <h5>Market Benefits:</h5>
            <ul>
              <li>Saves energy, extends robot battery life.</li>
              <li>Speeds up order fulfillment.</li>
              <li>Reduces robot wear and tear.</li>
              <li>Improves safety by avoiding hazards.</li>
              <li>Cuts operational costs.</li>
              <li>Supports scaling of robotic fleets.</li>
            </ul>

            <h5>Algorithm: UCS</h5>
            <p>
              UCS finds the lowest-cost path by always expanding the node with
              the smallest cumulative path cost. It uses a priority queue and
              guarantees the optimal path if costs are non-negative.
            </p>

            <ul>
              <li>
                Expands nodes based on cumulative cost, not depth or heuristics.
              </li>
              <li>Guarantees optimal and complete search.</li>
              <li>Does not require heuristics.</li>
              <li>Uses a priority queue for efficient node selection.</li>
              <li>Avoids revisiting nodes to prevent cycles.</li>
            </ul>

            <h5>Usage</h5>
            <p>
              In Amazon warehouses, robots navigate aisles where each path
              segment has different energy costs (e.g., narrow aisles, slippery
              floors). UCS helps find the route that uses the least energy, not
              necessarily the shortest path, by expanding paths based on their
              total energy cost. This ensures robots move efficiently, saving
              battery life and speeding up deliveries.
            </p>
            <!-- Analysis Section -->

            <h5>Analysis</h5>
            <ul>
              <li>
                <strong>Time Complexity:</strong> O(b<sup>C*/ε</sup>), where
                <em>b</em> is branching factor, <em>C*</em> is optimal cost, and
                <em>ε</em> is minimum step cost.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(b<sup>C*/ε</sup>) due to
                storing all generated nodes.
              </li>
              <li>
                <strong>Optimality:</strong> Always finds least-cost path if
                step costs are non-negative.
              </li>
              <li>
                <strong>Completeness:</strong> Guaranteed to find a solution if
                one exists.
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <img
              src="gif/ucs.gif"
              width="100%"
              height="600px"
              style="border: none"
            />
          </div>
          <div class="use-case">
            <h4>20.Real-Time Product Catalog Search Optimization</h4>
            <p>
              Amazon allows customers to find products that look similar by
              simply uploading an image. When a user provides a product photo,
              the system analyzes the visual features of the image and quickly
              searches through millions of product images in the catalog. It
              then returns the most visually similar products to the user in
              real time. This enhances the shopping experience by making product
              discovery easier, more intuitive, and tailored to what the
              customer actually wants visually.
            </p>

            <!-- <h5>Goal:</h5>
            <p>
              Reduce delivery times, improve efficiency, and minimize the carbon
              footprint.
            </p> -->

            <h5>Challenges:</h5>
            <ul>
              <li>Efficient search in high-dimensional image feature space</li>
              <li>Real-time query response for fast user experience</li>
              <li>Scalable handling of millions of product embeddings</li>
              <li>Accurate retrieval of visually similar products</li>
              <li>Lower memory and processing usage than brute-force search</li>
            </ul>
            <h5>Market Benefits:</h5>
            <ul>
              <li>Improved user experience with fast, relevant results</li>
              <li>Higher conversion rates through easier product discovery</li>
              <li>Competitive edge via innovative search capabilities</li>
              <li>Increased average order value from cross-selling</li>
              <li>Scalable solution with minimal added infrastructure cost</li>
              <li>Reduced bounce rates and longer user engagement</li>
              <li>Stronger brand loyalty from personalized search</li>
            </ul>
            <h5>Algorithm:KD-Tree</h5>
            <p>
              is a space-partitioning data structure for organizing points in
              k-dimensional space. It enables fast nearest neighbor searches by
              recursively dividing data using hyperplanes.
            </p>
            <p>
              It uses divide-and-conquer to split data along alternating
              dimensions, building a balanced tree. During search, it prunes
              irrelevant branches to efficiently find closest points.
            </p>

            <h5>Usage</h5>
            <p>A user uploads an image of a shoe to Amazon’s visual search.</p>
            <p>
              The system converts the image into a high-dimensional feature
              vector using a CNN.
            </p>
            <p>
              KD-Tree efficiently searches the product database for the top 5
              visually similar shoes.
            </p>
            <p>
              The results are displayed instantly, helping the user find
              matching or related products quickly.
            </p>

            <!-- Analysis Section -->

            <h5>Analysis</h5>
            <ul>
              <li>
                <strong>Construction Time:</strong> O(n log n) to build a
                balanced KD-Tree with n points.
              </li>
              <li>
                <strong>Search Time:</strong> Average O(log n) for nearest
                neighbor queries, but can degrade to O(n) in worst cases.
              </li>
              <li>
                <strong>Space Complexity:</strong> O(n), storing all points and
                tree nodes.
              </li>
              <li>
                <strong>Limitations:</strong> Performance decreases in very
                high-dimensional spaces (curse of dimensionality).
              </li>
            </ul>

            <a
              href="https://github.com/AnjaliSavalkar/Aps.github.io/tree/main/codes/segment_tree.c"
              style="font-size: 20px"
            >
              view code here
            </a>

            <!-- <h3>Segment Tree Visualization</h3>
            <iframe
              src="https://visualgo.net/en/segmenttree"
              width="100%"
              height="600px"
              style="border: none"
            ></iframe> -->
          </div>
        </div>
      </section>
    </main>

    <footer>
      <p>&copy; 2025 Anjali Savalkar. All rights reserved.</p>
    </footer>
  </body>
</html>
